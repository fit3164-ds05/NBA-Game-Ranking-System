{"version":3,"file":"AnnotationServiceImpl.js","sourceRoot":"","sources":["../../../../../src/ApiShared/Services/impl/AnnotationServiceImpl.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Contract from '@tableau/api-external-contract-js';\nimport { AnnotateEnum, Annotation, ExecuteParameters, ParameterId, VerbId, VisualId } from '@tableau/api-internal-contract-js';\nimport { InternalToExternalEnumMappings } from '../../EnumMappings/InternalToExternalEnumMappings';\nimport { SelectionModelsContainer, TupleSelectionModel } from '../../Models/SelectionModels';\nimport { TableauError } from '../../TableauError';\nimport { AnnotationService } from '../AnnotationService';\nimport { ServiceNames } from '../ServiceRegistry';\nimport { ServiceImplBase } from './ServiceImplBase';\n\nexport class AnnotationServiceImpl extends ServiceImplBase implements AnnotationService {\n  public get serviceName(): string {\n    return ServiceNames.Annotation;\n  }\n\n  /**\n   * Method to annotate a mark on the given worksheet.\n   *\n   * @param visualId\n   * @param mark\n   * @param annotationText\n   */\n  public annotateMarkAsync(visualId: VisualId, mark: Contract.MarkInfo, annotationText: string): Promise<void> {\n    const selectionModelContainer: SelectionModelsContainer = this.parseMarkSelectionIds([mark]);\n    const dummyTargetPoint = { x: 0, y: 0 };\n    const formattedText = `<formatted-text><run>${annotationText}</run></formatted-text>`;\n\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'annotateMarkAsync',\n      [ParameterId.VisualId]: visualId,\n      [ParameterId.AnnotateEnum]: AnnotateEnum.Mark,\n      [ParameterId.TargetPoint]: dummyTargetPoint,\n      [ParameterId.SelectionList]: [selectionModelContainer.selection],\n      [ParameterId.FormattedText]: formattedText,\n    };\n    return this.execute(VerbId.CreateAnnotation, parameters).then<void>((response) => {\n      // Expecting an empty model and hence the void response.\n      return;\n    });\n  }\n\n  /**\n   * Method to retrieve annotations for the given worksheet.\n   *\n   * @param visualId\n   * @returns {Promise<Array<Annotation>>}\n   */\n  public getAnnotationsAsync(visualId: VisualId): Promise<Array<Contract.Annotation>> {\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'getAnnotationsAsync',\n      [ParameterId.VisualId]: visualId,\n    };\n    return this.execute(VerbId.GetAnnotations, parameters).then<Array<Contract.Annotation>>((response) => {\n      const annotationsList = response.result as Array<Annotation>;\n      return this.annotationFilterMap(annotationsList);\n    });\n  }\n\n  /**\n   * Method to remove an annotation from a given worksheet.\n   *\n   * @param visualId\n   * @param annotation\n   */\n  public removeAnnotationAsync(visualId: VisualId, annotation: Contract.Annotation): Promise<void> {\n    const selectionModelContainer: SelectionModelsContainer = this.parseAnnotationSelectionIds([annotation]);\n\n    const parameters: ExecuteParameters = {\n      [ParameterId.FunctionName]: 'removeAnnotationAsync',\n      [ParameterId.VisualId]: visualId,\n      [ParameterId.SelectionList]: [selectionModelContainer.selection],\n    };\n    return this.execute(VerbId.RemoveAnnotation, parameters).then<void>((response) => {\n      // Expecting an empty model and hence the void response.\n      return;\n    });\n  }\n\n  /**\n   * Method to prepare the pres models for selection by MarksInfo\n   * @param marks\n   */\n  private parseMarkSelectionIds(marks: Array<Contract.MarkInfo>): SelectionModelsContainer {\n    const ids: Array<string> = [];\n    const selectionModelContainer: SelectionModelsContainer = new SelectionModelsContainer();\n    marks.forEach((mark) => {\n      const tupleId: number | undefined = mark.tupleId;\n      if (tupleId !== undefined && tupleId !== null && tupleId > 0) {\n        ids.push(tupleId.toString()); // collect the tuple ids\n      } else {\n        throw new TableauError(Contract.ErrorCodes.InternalError, 'invalid tupleId');\n      }\n    });\n    if (ids.length !== 0) {\n      // tuple ids based selection\n      const tupleSelectionModel: TupleSelectionModel = new TupleSelectionModel();\n      tupleSelectionModel.selectionType = 'tuples';\n      tupleSelectionModel.objectIds = ids;\n      selectionModelContainer.selection = tupleSelectionModel;\n    }\n    return selectionModelContainer;\n  }\n\n  /**\n   * Method to prepare the pres models for selection by MarkAnnotationInfo\n   * @param marks\n   */\n  private parseAnnotationSelectionIds(annotations: Array<Contract.Annotation>): SelectionModelsContainer {\n    const ids: Array<string> = [];\n    const selectionModelContainer: SelectionModelsContainer = new SelectionModelsContainer();\n    annotations.forEach((annotation) => {\n      const annotationId: number | undefined = annotation.annotationId;\n      if (annotationId !== undefined && annotationId !== null && annotationId >= 0) {\n        ids.push(annotationId.toString()); // collect the annotation ids\n      } else {\n        throw new TableauError(Contract.ErrorCodes.InternalError, 'invalid annotationId');\n      }\n    });\n    if (ids.length !== 0) {\n      // annotation ids based selection\n      const tupleSelectionModel: TupleSelectionModel = new TupleSelectionModel();\n      tupleSelectionModel.selectionType = 'annotations';\n      tupleSelectionModel.objectIds = ids;\n      selectionModelContainer.selection = tupleSelectionModel;\n    }\n    return selectionModelContainer;\n  }\n\n  /**\n   * Method to map Annotation to MarkAnnotationInfo\n   * @param annotation\n   * @returns {Annotation}\n   */\n  private mapAnnotation(annotation: Annotation): Contract.Annotation {\n    return {\n      annotationHTML: annotation.annotationText,\n      annotationId: annotation.annotationId,\n      annotationText: annotation.annotationPlainText,\n      annotationType: InternalToExternalEnumMappings.annotationType.convert(annotation.annotateEnum),\n      tupleId: annotation.tupleId!,\n    };\n  }\n\n  /**\n   * Filter the Annotations to Mark Annotations, and map them to MarkAnnotationInfo\n   * @param annotations\n   * @returns {Array<Annotation>}\n   */\n  private annotationFilterMap(annotations: Array<Annotation>): Array<Contract.Annotation> {\n    const annotationInfos = annotations.map((annotation) => this.mapAnnotation(annotation));\n\n    return annotationInfos;\n  }\n}\n"]}