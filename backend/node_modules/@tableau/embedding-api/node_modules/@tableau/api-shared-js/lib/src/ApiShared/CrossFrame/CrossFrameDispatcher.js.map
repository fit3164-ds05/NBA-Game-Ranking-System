{"version":3,"file":"CrossFrameDispatcher.js","sourceRoot":"","sources":["../../../../src/ApiShared/CrossFrame/CrossFrameDispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { EmbeddingErrorCodes } from '@tableau/api-external-contract-js';\nimport {\n  CommandResponseMessage,\n  ExecuteParameters,\n  ExecuteResponse,\n  InternalApiDispatcher,\n  Messenger,\n  Model,\n  NotificationHandler,\n  NotificationMessage,\n  VerbId,\n} from '@tableau/api-internal-contract-js';\nimport { TableauError } from '../TableauError';\n\n/**\n * This is an implementation of the InternalApiDispatcher interface which functions by passing messages\n * across a frame boundary. This is usually between the code where our javscript library has been included\n * by a 3rd party dev and another frame where Tableau server has content.\n */\nexport class CrossFrameDispatcher implements InternalApiDispatcher {\n  // Collection of pending promises which are waiting to be resolved. When we receive a response back from the other frame,\n  // these promises can be either resolved or rejected\n  private _pendingPromises: { [messageGuid: string]: { resolve: (response: ExecuteResponse) => void; reject: (error: Model) => void } } =\n    {};\n\n  // The collection of notification handlers which have been registered with this dispatcher\n  private _notificationHandlers: Array<NotificationHandler> = [];\n\n  /**\n   * Creates an instance of CrossFrameDispatcher which will use the given messenger to communicate\n   * @param _messenger an instantiated and listening messenger object\n   */\n  public constructor(private _messenger: Messenger) {\n    if (!this._messenger) {\n      throw 'Missing messenger object';\n    }\n\n    // Set up our message handlers. We only care about incoming notifications and command responses\n    this._messenger.setCommandResponseMessageHandler(this.onCommandResponse.bind(this));\n    this._messenger.setNotificationMessageHandler(this.onNotification.bind(this));\n  }\n\n  ////// Start InternalApiDispatcher implementation\n\n  public execute(verb: VerbId, parameters: ExecuteParameters): Promise<ExecuteResponse> {\n    // To execute a verb, we first prepare a command message and then define a promise.\n    const preparedMessage = this._messenger.prepareCommandMessage(verb, parameters);\n    const promise = new Promise<ExecuteResponse>((resolve, reject) => {\n      // Save off the pending promise by the messageGuid we are about to send. When a response is\n      // received, we'll be able to resolve this promise with the result\n      this._pendingPromises[preparedMessage.messageGuid] = { resolve: resolve, reject: reject };\n    });\n\n    // Actually send the message and return the promise\n    preparedMessage.send();\n    return promise;\n  }\n\n  public registerNotificationHandler(handler: NotificationHandler): void {\n    this._notificationHandlers.push(handler);\n  }\n\n  public unregisterNotificationHandler(handler: NotificationHandler): void {\n    this._notificationHandlers = this._notificationHandlers.filter((h) => h !== handler);\n  }\n\n  ////// End InternalApiDispatcher implementation\n\n  private onCommandResponse(response: CommandResponseMessage): void {\n    // We got a command response, look through the pending promises and resolve\n    if (Object.keys(this._pendingPromises).indexOf(response.commandGuid) < 0) {\n      return; // We don't have any reference to this command, just return\n    }\n\n    const pendingPromise = this._pendingPromises[response.commandGuid];\n\n    // If we have an error defined, reject the promise\n    if (response.error) {\n      pendingPromise.reject(response.error);\n    }\n\n    // If we have data defined, resolve the promise\n    if (response.data) {\n      pendingPromise.resolve({ result: response.data });\n    }\n\n    // Clean up our pending promises object\n    delete this._pendingPromises[response.commandGuid];\n  }\n\n  private onNotification(notificationMessage: NotificationMessage): void {\n    // Go through each notification handler we have registered and let them know a notification came in\n    for (const handler of this._notificationHandlers) {\n      try {\n        handler({ notificationId: notificationMessage.notificationId, data: notificationMessage.data });\n      } catch (e) {\n        // Incase of a IncompatibleVersionError, re-throw the error.\n        if ((e as TableauError).errorCode === EmbeddingErrorCodes.IncompatibleVersionError) {\n          throw e;\n        }\n        // Else Ignore  so if one handler errors, the other still get the message.\n      }\n    }\n  }\n}\n"]}