"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Contract = require("@tableau/api-external-contract-js");
var api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
var InternalToExternalEnumMappings_1 = require("../../EnumMappings/InternalToExternalEnumMappings");
var SelectionModels_1 = require("../../Models/SelectionModels");
var TableauError_1 = require("../../TableauError");
var ServiceImplBase_1 = require("./ServiceImplBase");
var AnnotationServiceImpl = /** @class */ (function (_super) {
    __extends(AnnotationServiceImpl, _super);
    function AnnotationServiceImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(AnnotationServiceImpl.prototype, "serviceName", {
        get: function () {
            return "annotation-service" /* Annotation */;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Method to annotate a mark on the given worksheet.
     *
     * @param visualId
     * @param mark
     * @param annotationText
     */
    AnnotationServiceImpl.prototype.annotateMarkAsync = function (visualId, mark, annotationText) {
        var _a;
        var selectionModelContainer = this.parseMarkSelectionIds([mark]);
        var dummyTargetPoint = { x: 0, y: 0 };
        var formattedText = "<formatted-text><run>" + annotationText + "</run></formatted-text>";
        var parameters = (_a = {},
            _a[api_internal_contract_js_1.ParameterId.FunctionName] = 'annotateMarkAsync',
            _a[api_internal_contract_js_1.ParameterId.VisualId] = visualId,
            _a[api_internal_contract_js_1.ParameterId.AnnotateEnum] = api_internal_contract_js_1.AnnotateEnum.Mark,
            _a[api_internal_contract_js_1.ParameterId.TargetPoint] = dummyTargetPoint,
            _a[api_internal_contract_js_1.ParameterId.SelectionList] = [selectionModelContainer.selection],
            _a[api_internal_contract_js_1.ParameterId.FormattedText] = formattedText,
            _a);
        return this.execute(api_internal_contract_js_1.VerbId.CreateAnnotation, parameters).then(function (response) {
            // Expecting an empty model and hence the void response.
            return;
        });
    };
    /**
     * Method to retrieve annotations for the given worksheet.
     *
     * @param visualId
     * @returns {Promise<Array<Annotation>>}
     */
    AnnotationServiceImpl.prototype.getAnnotationsAsync = function (visualId) {
        var _a;
        var _this = this;
        var parameters = (_a = {},
            _a[api_internal_contract_js_1.ParameterId.FunctionName] = 'getAnnotationsAsync',
            _a[api_internal_contract_js_1.ParameterId.VisualId] = visualId,
            _a);
        return this.execute(api_internal_contract_js_1.VerbId.GetAnnotations, parameters).then(function (response) {
            var annotationsList = response.result;
            return _this.annotationFilterMap(annotationsList);
        });
    };
    /**
     * Method to remove an annotation from a given worksheet.
     *
     * @param visualId
     * @param annotation
     */
    AnnotationServiceImpl.prototype.removeAnnotationAsync = function (visualId, annotation) {
        var _a;
        var selectionModelContainer = this.parseAnnotationSelectionIds([annotation]);
        var parameters = (_a = {},
            _a[api_internal_contract_js_1.ParameterId.FunctionName] = 'removeAnnotationAsync',
            _a[api_internal_contract_js_1.ParameterId.VisualId] = visualId,
            _a[api_internal_contract_js_1.ParameterId.SelectionList] = [selectionModelContainer.selection],
            _a);
        return this.execute(api_internal_contract_js_1.VerbId.RemoveAnnotation, parameters).then(function (response) {
            // Expecting an empty model and hence the void response.
            return;
        });
    };
    /**
     * Method to prepare the pres models for selection by MarksInfo
     * @param marks
     */
    AnnotationServiceImpl.prototype.parseMarkSelectionIds = function (marks) {
        var ids = [];
        var selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        marks.forEach(function (mark) {
            var tupleId = mark.tupleId;
            if (tupleId !== undefined && tupleId !== null && tupleId > 0) {
                ids.push(tupleId.toString()); // collect the tuple ids
            }
            else {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'invalid tupleId');
            }
        });
        if (ids.length !== 0) {
            // tuple ids based selection
            var tupleSelectionModel = new SelectionModels_1.TupleSelectionModel();
            tupleSelectionModel.selectionType = 'tuples';
            tupleSelectionModel.objectIds = ids;
            selectionModelContainer.selection = tupleSelectionModel;
        }
        return selectionModelContainer;
    };
    /**
     * Method to prepare the pres models for selection by MarkAnnotationInfo
     * @param marks
     */
    AnnotationServiceImpl.prototype.parseAnnotationSelectionIds = function (annotations) {
        var ids = [];
        var selectionModelContainer = new SelectionModels_1.SelectionModelsContainer();
        annotations.forEach(function (annotation) {
            var annotationId = annotation.annotationId;
            if (annotationId !== undefined && annotationId !== null && annotationId >= 0) {
                ids.push(annotationId.toString()); // collect the annotation ids
            }
            else {
                throw new TableauError_1.TableauError(Contract.ErrorCodes.InternalError, 'invalid annotationId');
            }
        });
        if (ids.length !== 0) {
            // annotation ids based selection
            var tupleSelectionModel = new SelectionModels_1.TupleSelectionModel();
            tupleSelectionModel.selectionType = 'annotations';
            tupleSelectionModel.objectIds = ids;
            selectionModelContainer.selection = tupleSelectionModel;
        }
        return selectionModelContainer;
    };
    /**
     * Method to map Annotation to MarkAnnotationInfo
     * @param annotation
     * @returns {Annotation}
     */
    AnnotationServiceImpl.prototype.mapAnnotation = function (annotation) {
        return {
            annotationHTML: annotation.annotationText,
            annotationId: annotation.annotationId,
            annotationText: annotation.annotationPlainText,
            annotationType: InternalToExternalEnumMappings_1.InternalToExternalEnumMappings.annotationType.convert(annotation.annotateEnum),
            tupleId: annotation.tupleId,
        };
    };
    /**
     * Filter the Annotations to Mark Annotations, and map them to MarkAnnotationInfo
     * @param annotations
     * @returns {Array<Annotation>}
     */
    AnnotationServiceImpl.prototype.annotationFilterMap = function (annotations) {
        var _this = this;
        var annotationInfos = annotations.map(function (annotation) { return _this.mapAnnotation(annotation); });
        return annotationInfos;
    };
    return AnnotationServiceImpl;
}(ServiceImplBase_1.ServiceImplBase));
exports.AnnotationServiceImpl = AnnotationServiceImpl;
//# sourceMappingURL=AnnotationServiceImpl.js.map