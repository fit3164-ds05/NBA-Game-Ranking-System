{"version":3,"file":"ExternalVersionTranslations.js","sourceRoot":"","sources":["../../../../src/versioning/external/ExternalVersionTranslations.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DataHeader,\n  DataTable,\n  DataTypeConverter,\n  ExecuteParameters,\n  ExecuteResponse,\n  Notification,\n  ParameterId,\n  SelectedMarksTable,\n  UnderlyingDataTable,\n  VerbId,\n} from '../../JsApiInternalContract';\n\n// tslint:disable:no-any\n\n/** This function is called when we receive newer version and parameters from the external before we send it to platform */\nexport type DowngradeExecuteCall = (verb: VerbId, parameters: ExecuteParameters) => { verb: VerbId; parameters: ExecuteParameters };\n\n/** This function is called when we receive a response back from platform and we need to upgrade it to external's version\n *  The verb and parameters provide a context to decide how to handle the response.\n */\nexport type UpgradeExecuteReturn = (executeResponse: ExecuteResponse, verb: VerbId, parameters: ExecuteParameters) => ExecuteResponse;\n\n/** This function is called when we receive a notification from platform and we need to upgrade it to external's version */\nexport type UpgradeNotification = (notification: Notification) => Notification;\n\n// 1.2 -> 1.0 Translations\n// Uncomment this line to import from the V1 definition of the API\n// import * as V1 from '@tableau-api-internal-contract-js_v1';\n\n/**\n * Prior to 2019.2 (internal-contract v1.9), DataValue.value were all strings.\n * Go through all DataValue objects. If we have a string, but the type should not be a string,\n * convert it to the correct type. The type of DataValue.value is 'any' in the contract, so\n * this change doesn't need any updates to classes or types.\n */\nexport function UpgradeDataTableTypes(executeResponse: ExecuteResponse, verb: VerbId, parameters: ExecuteParameters): ExecuteResponse {\n  if (!executeResponse) {\n    return executeResponse;\n  }\n\n  const oldUnderlyingDataTable = executeResponse.result as UnderlyingDataTable;\n  if (oldUnderlyingDataTable.data !== undefined && oldUnderlyingDataTable.isSummary !== undefined) {\n    convertDataValues(oldUnderlyingDataTable.data);\n    return executeResponse;\n  }\n\n  const oldSelectedMarksTable = executeResponse.result as SelectedMarksTable;\n  if (oldSelectedMarksTable.data !== undefined && Array.isArray(oldSelectedMarksTable.data)) {\n    oldSelectedMarksTable.data.forEach((marksTable) => {\n      convertDataValues(marksTable);\n    });\n    return executeResponse;\n  }\n\n  return executeResponse;\n}\n\nfunction convertDataValues(table: DataTable): void {\n  // dataTable is a two-dimensional array of data. First index is the row, second is the column.\n  if (table === undefined || table.dataTable === undefined || !Array.isArray(table.dataTable)) {\n    return;\n  }\n\n  table.dataTable.forEach((row) => {\n    row.forEach((dataValue, columnIndex) => {\n      const value = dataValue.value;\n      if (value !== null) {\n        dataValue.value = DataTypeConverter.convertValueAsStringToValue(value, table.headers[columnIndex].dataType);\n      }\n    });\n  });\n}\n\n/**\n * Prior to 2021.2 (internal-contract v1.29 and below), getSummaryDataAsync did not support maxRows,\n * and any get...DataAsync did not support columnsToIncludeById.\n * Trim result to maxRows if it is included in the parameters for getSummaryDataAsync\n * Trim columns to columnsToInclude if included in the parameters for any get...DataAsync\n */\nexport function UpgradeDataTableRowsAndColumns(\n  executeResponse: ExecuteResponse,\n  verb: VerbId,\n  parameters: ExecuteParameters,\n): ExecuteResponse {\n  if (isGetSummaryDataVerb(verb) && parameters[ParameterId.MaxRows]) {\n    executeResponse = adjustDataRowLength(executeResponse, parameters[ParameterId.MaxRows] as number);\n  }\n\n  if (isGetTableDataVerb(verb) && parameters[ParameterId.ColumnsToIncludeById]) {\n    executeResponse = adjustDataColumns(executeResponse, parameters[ParameterId.ColumnsToIncludeById] as string[]);\n  }\n\n  return executeResponse;\n}\n\nfunction isGetSummaryDataVerb(verb: VerbId): boolean {\n  return verb === VerbId.GetDataSummaryData;\n}\n\nfunction isGetTableDataVerb(verb: VerbId): boolean {\n  return (\n    verb === VerbId.GetDataSummaryData ||\n    verb === VerbId.GetUnderlyingTableData ||\n    verb === VerbId.GetLogicalTableData ||\n    verb === VerbId.GetDataSourceData ||\n    verb === VerbId.GetUnderlyingData\n  );\n}\n\nfunction adjustDataRowLength(executeResponse: ExecuteResponse, maxRows: number): ExecuteResponse {\n  const underlyingDataTable = executeResponse.result as UnderlyingDataTable;\n  if (!underlyingDataTable.data || !Array.isArray(underlyingDataTable.data.dataTable)) {\n    return executeResponse;\n  }\n\n  if (maxRows > 0 && maxRows < underlyingDataTable.data.dataTable.length) {\n    underlyingDataTable.data.dataTable.length = maxRows;\n  }\n  return executeResponse;\n}\n\nfunction adjustDataColumns(executeResponse: ExecuteResponse, columnsToInclude: string[]): ExecuteResponse {\n  if (columnsToInclude.length === 0) {\n    return executeResponse;\n  }\n\n  // verify that we have a valid UnderlyingDataTable\n  const underlyingDataTable = executeResponse.result as UnderlyingDataTable;\n  if (!underlyingDataTable.data || !Array.isArray(underlyingDataTable.data.dataTable) || !Array.isArray(underlyingDataTable.data.headers)) {\n    return executeResponse;\n  }\n\n  // 1. filter the headers to only columnsToInclude\n  // 2. use the new headers to filter all rows\n  // 3. update the indices in our new headers\n  const newHeaders: DataHeader[] = underlyingDataTable.data.headers.filter((header, index) =>\n    columnsToInclude.find((name) => name === header.fieldName),\n  );\n  underlyingDataTable.data.dataTable.forEach((row, index) => {\n    underlyingDataTable.data.dataTable[index] = row.filter(\n      (value, valueIndex) => newHeaders.findIndex((header) => header.index === valueIndex) !== -1,\n    );\n  });\n  let newIndex = 0;\n  underlyingDataTable.data.headers = newHeaders.map((header) => {\n    header.index = newIndex++;\n    return header;\n  });\n\n  return executeResponse;\n}\n"]}