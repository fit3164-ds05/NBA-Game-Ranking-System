{"version":3,"file":"CrossFrameMessenger.js","sourceRoot":"","sources":["../../../src/messaging/CrossFrameMessenger.ts"],"names":[],"mappings":";;AAAA,2BAA6B;AAC7B,kEAAsI;AAEtI,yEAAwE;AACxE,yDAO6B;AAQ7B,yDAQkC;AAIlC;;;;;GAKG;AACH;IAQE;;;;;;;;;OASG;IACH,6BAA2B,UAAkB,EAAU,WAAoB,EAAU,iBAA0B;QAApF,eAAU,GAAV,UAAU,CAAQ;QAAU,gBAAW,GAAX,WAAW,CAAS;QAAU,sBAAiB,GAAjB,iBAAiB,CAAS;QAC7G,mCAAmC;IACrC,CAAC;IAED,oCAAoC;IAE7B,4CAAc,GAArB;QAAA,iBAOC;QANC,wEAAwE;QACxE,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC5B,IAAM,cAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvD,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,SAAS,EAAE,cAAY,EAAE,IAAI,CAAC,CAAC;YAChE,IAAI,CAAC,kBAAkB,GAAG,cAAM,OAAA,KAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,SAAS,EAAE,cAAY,EAAE,IAAI,CAAC,EAAlE,CAAkE,CAAC;SACpG;IACH,CAAC;IAEM,2CAAa,GAApB;QACE,8CAA8C;QAC9C,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC;SACrC;IACH,CAAC;IAEM,yDAA2B,GAAlC,UAAmC,OAAkC;QACnE,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC;IAC1C,CAAC;IAEM,8DAAgC,GAAvC,UAAwC,OAAuC;QAC7E,IAAI,CAAC,6BAA6B,GAAG,OAAO,CAAC;IAC/C,CAAC;IAEM,sDAAwB,GAA/B,UAAgC,OAA+B;QAC7D,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC;IACvC,CAAC;IAEM,2DAA6B,GAApC,UAAqC,OAAoC;QACvE,IAAI,CAAC,0BAA0B,GAAG,OAAO,CAAC;IAC5C,CAAC;IAEM,wDAA0B,GAAjC,UAAkC,OAAiC;QACjE,IAAI,CAAC,uBAAuB,GAAG,OAAO,CAAC;IACzC,CAAC;IAED,sCAAsC;IAEtC;;;;;OAKG;IACI,0DAA4B,GAAnC,UACE,UAAyB,EACzB,iBAAgC,EAChC,OAA+B;QAE/B,IAAM,OAAO,GAAsB;YACjC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;YACnB,OAAO,EAAE,0BAAW,CAAC,UAAU;YAC/B,iBAAiB,EAAE,iBAAiB;YACpC,UAAU,EAAE,UAAU;YACtB,OAAO,EAAE,OAAO;SACjB,CAAC;QAEF,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAEM,mDAAqB,GAA5B,UAA6B,MAAc,EAAE,UAA6B;QACxE,IAAM,OAAO,GAAmB;YAC9B,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;YACnB,OAAO,EAAE,0BAAW,CAAC,OAAO;YAC5B,MAAM,EAAE,MAAM;YACd,UAAU,EAAE,UAAU;SACvB,CAAC;QAEF,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAEM,2DAA6B,GAApC,UAAqC,WAAmB,EAAE,IAAuB,EAAE,KAAwB;QACzG,IAAM,OAAO,GAA2B;YACtC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;YACnB,OAAO,EAAE,0BAAW,CAAC,eAAe;YACpC,WAAW,EAAE,WAAW;YACxB,IAAI,EAAE,IAAI;YACV,KAAK,EAAE,KAAK;SACb,CAAC;QAEF,IAAI,KAAK,EAAE;YACT,yGAAyG;YACzG,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;SACnD;QAED,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAEM,wDAA0B,GAAjC,UAAkC,cAA8B,EAAE,IAAW;QAC3E,IAAM,OAAO,GAAwB;YACnC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;YACnB,OAAO,EAAE,0BAAW,CAAC,YAAY;YACjC,cAAc,EAAE,cAAc;YAC9B,IAAI,EAAE,IAAI;SACX,CAAC;QAEF,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAEM,+CAAiB,GAAxB;QACE,IAAM,OAAO,GAAqB;YAChC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;YACnB,OAAO,EAAE,0BAAW,CAAC,GAAG;YACxB,eAAe,EAAE,iDAAyB;SAC3C,CAAC;QAEF,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;IAED;;;;;OAKG;IACK,4CAAc,GAAtB,UAAuB,GAAY;QACjC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAChD,MAAM,wDAAwD,CAAC;SAChE;QAED,IAAM,eAAe,GAAG,IAAI,qDAAyB,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACrG,OAAO,eAAe,CAAC;IACzB,CAAC;IAED;;;;;OAKG;IACK,+CAAiB,GAAzB,UAA0B,KAAmB;QAC3C,gFAAgF;QAChF,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,WAAW,EAAE;YACzD,OAAO;SACR;QAED,qFAAqF;QACrF,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;YACf,OAAO;SACR;QAED,IAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC;QAC3B,IAAI,CAAC,6BAAS,CAAC,OAAO,CAAC,EAAE;YACvB,OAAO;SACR;QAED,sGAAsG;QACtG,QAAQ,OAAO,CAAC,OAAO,EAAE;YACvB,KAAK,0BAAW,CAAC,UAAU,CAAC,CAAC;gBAC3B,IAAI,CAAC,iCAAa,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,EAAE;oBAC7D,OAAO;iBACR;gBAED,IAAI,CAAC,wBAAwB,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;gBACrD,MAAM;aACP;YACD,KAAK,0BAAW,CAAC,eAAe,CAAC,CAAC;gBAChC,IAAI,CAAC,4CAAwB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,6BAA6B,EAAE;oBAC7E,OAAO;iBACR;gBAED,IAAI,CAAC,6BAA6B,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC1D,MAAM;aACP;YACD,KAAK,0BAAW,CAAC,OAAO,CAAC,CAAC;gBACxB,IAAI,CAAC,oCAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE;oBAC7D,OAAO;iBACR;gBAED,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;gBAClD,MAAM;aACP;YACD,KAAK,0BAAW,CAAC,YAAY,CAAC,CAAC;gBAC7B,IAAI,CAAC,yCAAqB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE;oBACvE,OAAO;iBACR;gBAED,IAAI,CAAC,0BAA0B,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;gBACvD,MAAM;aACP;YACD,KAAK,0BAAW,CAAC,SAAS,CAAC,CAAC;gBAC1B,IAAI,CAAC,sCAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,uBAAuB,EAAE;oBACjE,OAAO;iBACR;gBAED,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;gBACpD,MAAM;aACP;YACD,QAAQ;YACR,sEAAsE;SACvE;IACH,CAAC;IAEM,4CAAc,GAArB,UAAsB,WAAmB;QACvC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAEM,kDAAoB,GAA3B,UAA4B,MAAc;QACxC,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC;IAClC,CAAC;IACH,0BAAC;AAAD,CAAC,AAjOD,IAiOC;AAjOY,kDAAmB","sourcesContent":["import * as guid from 'guid';\nimport { ExecuteParameters, INTERNAL_CONTRACT_VERSION, Model, NotificationId, VerbId, VersionNumber } from '../JsApiInternalContract';\nimport { InitializationOptions } from '../interface/InitializationOptions';\nimport { CrossFramePreparedMessage } from './CrossFramePreparedMessage';\nimport {\n  isCommandMessage,\n  isCommandResponseMessage,\n  isHandshakeMessage,\n  isInitMessage,\n  isMessage,\n  isNotificationMessage,\n} from './MessageTypeChecks';\nimport {\n  CommandMessageHandler,\n  CommandResponseMessageHandler,\n  HandshakeMessageHandler,\n  InitializeMessageHandler,\n  NotificationMessageHandler,\n} from './interface/MessageListener';\nimport {\n  CommandMessage,\n  CommandResponseMessage,\n  HandshakeMessage,\n  InitializeMessage,\n  Message,\n  MessageType,\n  NotificationMessage,\n} from './interface/MessageTypes';\nimport { Messenger } from './interface/Messenger';\nimport { PreparedMessage } from './interface/PreparedMessage';\n\n/**\n * The CrossFrameMessenger is the primary export from the api-messaging module. An instance of\n * this class can be instantiated on both sides of a frame boundary to facilitate communication\n * in both directions between the frames. This class implements both the dispatcher and the listener\n * portions, but doesn't require callers to care about both.\n */\nexport class CrossFrameMessenger implements Messenger {\n  private unregisterFunction?: () => void;\n  private initializeMessageHandler?: InitializeMessageHandler;\n  private commandResponseMessageHandler?: CommandResponseMessageHandler;\n  private commandMessageHandler?: CommandMessageHandler;\n  private notificationMessageHandler?: NotificationMessageHandler;\n  private handshakeMessageHandler?: HandshakeMessageHandler;\n\n  /**\n   * Creates an instance of CrossFrameMessenger. If you would like to use the CrossFrameMessenger as a MessageListener,\n   * be sure to call StartListening and register message handlers.\n   * @param thisWindow The window object which the CrossFrameMessenger lives. An onMessage listener will be added here.\n   * @param [otherWindow] Optional otherWindow which messages will be posted to.\n   *                      If defined, incoming messages must originate from otherWindow to be passed on\n   * @param [otherWindowOrigin] The target origin which otherWindow must have in order to receive dispatched messages.\n   *                            This value will be sent as the targetOrigin of a postMessage\n   *                            (https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)\n   */\n  public constructor(private thisWindow: Window, private otherWindow?: Window, private otherWindowOrigin?: string) {\n    // Make sure to call StartListening\n  }\n\n  ///// MessageListener Implementation\n\n  public startListening(): void {\n    // Check if we already are listening, if not, hook up a message listener\n    if (!this.unregisterFunction) {\n      const boundHandler = this.onMessageReceived.bind(this);\n      this.thisWindow.addEventListener('message', boundHandler, true);\n      this.unregisterFunction = () => this.thisWindow.removeEventListener('message', boundHandler, true);\n    }\n  }\n\n  public stopListening(): void {\n    // Stop listening if we have started listening\n    if (this.unregisterFunction) {\n      this.unregisterFunction();\n      this.unregisterFunction = undefined;\n    }\n  }\n\n  public setInitializeMessageHandler(handler?: InitializeMessageHandler): void {\n    this.initializeMessageHandler = handler;\n  }\n\n  public setCommandResponseMessageHandler(handler?: CommandResponseMessageHandler): void {\n    this.commandResponseMessageHandler = handler;\n  }\n\n  public setCommandMessageHandler(handler?: CommandMessageHandler): void {\n    this.commandMessageHandler = handler;\n  }\n\n  public setNotificationMessageHandler(handler?: NotificationMessageHandler): void {\n    this.notificationMessageHandler = handler;\n  }\n\n  public setHandshakeMessageHandler(handler?: HandshakeMessageHandler): void {\n    this.handshakeMessageHandler = handler;\n  }\n\n  ///// MessageDispatcher Implementation\n\n  /**\n   * @param apiVersion api-internal-contract-js version (exported in JsApiInternalConntract)\n   * @param crossFrameVersion crossframe messaging version (exported in JsApiInternalConntract)\n   * @param options additional options that can be passed at initialization (information about the version of\n   *                external being used for example)\n   */\n  public prepareInitializationMessage(\n    apiVersion: VersionNumber,\n    crossFrameVersion: VersionNumber,\n    options?: InitializationOptions,\n  ): PreparedMessage {\n    const message: InitializeMessage = {\n      msgGuid: guid.raw(),\n      msgType: MessageType.Initialize,\n      crossFrameVersion: crossFrameVersion,\n      apiVersion: apiVersion,\n      options: options,\n    };\n\n    return this.prepareMessage(message);\n  }\n\n  public prepareCommandMessage(verbId: VerbId, parameters: ExecuteParameters): PreparedMessage {\n    const message: CommandMessage = {\n      msgGuid: guid.raw(),\n      msgType: MessageType.Command,\n      verbId: verbId,\n      parameters: parameters,\n    };\n\n    return this.prepareMessage(message);\n  }\n\n  public prepareCommandResponseMessage(commandGuid: string, data: Model | undefined, error: Model | undefined): PreparedMessage {\n    const message: CommandResponseMessage = {\n      msgGuid: guid.raw(),\n      msgType: MessageType.CommandResponse,\n      commandGuid: commandGuid,\n      data: data,\n      error: error,\n    };\n\n    if (error) {\n      // stringify error object to remove unserializable fields like functions and prevent serialization errors\n      message.error = JSON.parse(JSON.stringify(error));\n    }\n\n    return this.prepareMessage(message);\n  }\n\n  public prepareNotificationMessage(notificationId: NotificationId, data: Model): PreparedMessage {\n    const message: NotificationMessage = {\n      msgGuid: guid.raw(),\n      msgType: MessageType.Notification,\n      notificationId: notificationId,\n      data: data,\n    };\n\n    return this.prepareMessage(message);\n  }\n\n  public prepareAckMessage(): PreparedMessage {\n    const message: HandshakeMessage = {\n      msgGuid: guid.raw(),\n      msgType: MessageType.Ack,\n      platformVersion: INTERNAL_CONTRACT_VERSION,\n    };\n\n    return this.prepareMessage(message);\n  }\n\n  /**\n   * Prepares a pending message for sending and returns the prepared message\n   *\n   * @param msg The message to be sent to this.otherWindow\n   * @returns The prepared message\n   */\n  private prepareMessage(msg: Message): PreparedMessage {\n    if (!this.otherWindow || !this.otherWindowOrigin) {\n      throw 'Other window not initialized, cannot dispatch messages';\n    }\n\n    const preparedMessage = new CrossFramePreparedMessage(msg, this.otherWindow, this.otherWindowOrigin);\n    return preparedMessage;\n  }\n\n  /**\n   * Called when a message is received. Does some validation of the message, and then\n   * calls an appropriate message handler if one is defined\n   *\n   * @param event The incoming MessageEvent\n   */\n  private onMessageReceived(event: MessageEvent): void {\n    // If we have an otherWindow defined, make sure the message is coming from there\n    if (this.otherWindow && event.source !== this.otherWindow) {\n      return;\n    }\n\n    // Do some validation on event.data to make sure that we have received a real message\n    if (!event.data) {\n      return;\n    }\n\n    const message = event.data;\n    if (!isMessage(message)) {\n      return;\n    }\n\n    // Check the declared message type, validate the message, and call an appropriate hander if one exists\n    switch (message.msgType) {\n      case MessageType.Initialize: {\n        if (!isInitMessage(message) || !this.initializeMessageHandler) {\n          return;\n        }\n\n        this.initializeMessageHandler(message, event.source);\n        break;\n      }\n      case MessageType.CommandResponse: {\n        if (!isCommandResponseMessage(message) || !this.commandResponseMessageHandler) {\n          return;\n        }\n\n        this.commandResponseMessageHandler(message, event.source);\n        break;\n      }\n      case MessageType.Command: {\n        if (!isCommandMessage(message) || !this.commandMessageHandler) {\n          return;\n        }\n\n        this.commandMessageHandler(message, event.source);\n        break;\n      }\n      case MessageType.Notification: {\n        if (!isNotificationMessage(message) || !this.notificationMessageHandler) {\n          return;\n        }\n\n        this.notificationMessageHandler(message, event.source);\n        break;\n      }\n      case MessageType.Handshake: {\n        if (!isHandshakeMessage(message) || !this.handshakeMessageHandler) {\n          return;\n        }\n\n        this.handshakeMessageHandler(message, event.source);\n        break;\n      }\n      default:\n      // Just ignore this since we don't know how to handle the message type\n    }\n  }\n\n  public setOtherWindow(otherWindow: Window): void {\n    this.otherWindow = otherWindow;\n  }\n\n  public setOtherWindowOrigin(origin: string): void {\n    this.otherWindowOrigin = origin;\n  }\n}\n"]}