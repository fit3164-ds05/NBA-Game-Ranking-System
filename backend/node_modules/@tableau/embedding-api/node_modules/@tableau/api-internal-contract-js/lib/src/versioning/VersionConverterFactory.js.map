{"version":3,"file":"VersionConverterFactory.js","sourceRoot":"","sources":["../../../src/versioning/VersionConverterFactory.ts"],"names":[],"mappings":";;AACA,uEAAsE;AAEtE,uEAAsE;AAEtE,6DAK+B;AAE/B;;;;GAIG;AACH,SAAgB,eAAe,CAAC,GAAkB,EAAE,GAAkB;IACpE,IAAI,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,EAAE;QACzB,OAAO,KAAK,CAAC;KACd;IACD,IAAI,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,EAAE;QACzB,OAAO,IAAI,CAAC;KACb;IACD,OAAO,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;AAC/B,CAAC;AARD,0CAQC;AAED;;;;GAIG;AACH,SAAgB,cAAc,CAAC,GAAkB,EAAE,GAAkB;IACnE,OAAO,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,CAAC;AAC5D,CAAC;AAFD,wCAEC;AAMD,gHAAgH;AAChH,+FAA+F;AAC/F,8GAA8G;AAC9G,2GAA2G;AAC3G,oHAAoH;AACpH,mGAAmG;AACtF,QAAA,oBAAoB,GAA2D;IAC1F,CAAC,EAAE;QACD,CAAC,EAAE,EAAE;KACN;CACF,CAAC;AAEW,QAAA,sBAAsB,GAA+D;IAChG,CAAC,EAAE;QACD,CAAC,EAAE,CAAC,6CAAuB,CAAC;QAC5B,CAAC,EAAE,EAAE;QACL,GAAG,EAAE,CAAC,oDAA8B,CAAC;KACtC;CACF,CAAC;AAEW,QAAA,2BAA2B,GAA8D;IACpG,CAAC,EAAE;QACD,CAAC,EAAE,EAAE;QACL,EAAE,EAAE,CAAC,8CAAwB,CAAC;QAC9B,GAAG,EAAE,CAAC,gEAA0C,CAAC;KAClD;CACF,CAAC;AAEF;;;;;;;;GAQG;AACH,SAAgB,sBAAsB,CAAC,eAA8B,EAAE,eAA8B;IACnG,OAAO,qCAAqC,CAC1C,eAAe,EACf,eAAe,EACf,4BAAoB,EACpB,8BAAsB,EACtB,mCAA2B,CAC5B,CAAC;AACJ,CAAC;AARD,wDAQC;AAED;;;;;;;;;GASG;AACH,SAAgB,qCAAqC,CACnD,eAA8B,EAC9B,eAA8B,EAC9B,QAAgE,EAChE,UAAsE,EACtE,sBAAiF;IAEjF,IAAM,oBAAoB,GAAW,eAAe,CAAC,KAAK,CAAC;IAC3D,IAAM,oBAAoB,GAAW,eAAe,CAAC,KAAK,CAAC;IAC3D,IAAM,oBAAoB,GAAW,eAAe,CAAC,KAAK,CAAC;IAE3D,IAAI,oBAAoB,GAAG,oBAAoB,EAAE;QAC/C,MAAM,IAAI,KAAK,CAAC,gGACO,oBAAoB,8BAAyB,oBAAsB,CAAC,CAAC;KAC7F;IAED,yFAAyF;IACzF,IAAI,cAAc,CAAC,eAAe,EAAE,eAAe,CAAC,EAAE;QACpD,OAAO,IAAI,mDAAwB,EAAE,CAAC;KACvC;IAED,mGAAmG;IACnG,IAAM,qBAAqB,GAA2C,qBAAqB,CACzF,oBAAoB,EACpB,oBAAoB,EACpB,oBAAoB,EACpB,QAAQ,CACT,CAAC;IAEF,IAAM,uBAAuB,GAA+C,qBAAqB,CAC/F,oBAAoB,EACpB,oBAAoB,EACpB,oBAAoB,EACpB,UAAU,CACX,CAAC;IAEF,IAAM,4BAA4B,GAA8C,qBAAqB,CACnG,oBAAoB,EACpB,oBAAoB,EACpB,oBAAoB,EACpB,sBAAsB,CACvB,CAAC;IAEF,wFAAwF;IACxF,uBAAuB,CAAC,OAAO,EAAE,CAAC;IAClC,4BAA4B,CAAC,OAAO,EAAE,CAAC;IAEvC,OAAO,mDAAwB,CAAC,QAAQ,CACtC,eAAe,EACf,eAAe,EACf,qBAAqB,EACrB,uBAAuB,EACvB,4BAA4B,CAC7B,CAAC;AACJ,CAAC;AAtDD,sFAsDC;AAED,SAAS,qBAAqB,CAC5B,oBAA4B,EAC5B,oBAA4B,EAC5B,oBAA4B,EAC5B,qBAA+C;IAE/C,IAAM,kBAAkB,GAAa,EAAE,CAAC;IAExC,KAAK,IAAI,KAAK,GAAG,oBAAoB,EAAE,KAAK,IAAI,oBAAoB,EAAE,KAAK,EAAE,EAAE;QAC7E,IAAI,KAAK,IAAI,qBAAqB,EAAE;YAClC,IAAM,KAAK,GAAG,KAAK,KAAK,oBAAoB,CAAC,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;YACxE,IAAM,mBAAmB,GAAG,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5F,KAAK,IAAI,KAAK,GAAG,KAAK,EAAE,KAAK,IAAI,mBAAmB,EAAE,KAAK,EAAE,EAAE;gBAC7D,IAAI,KAAK,IAAI,qBAAqB,CAAC,KAAK,CAAC,EAAE;oBACzC,kBAAkB,CAAC,IAAI,OAAvB,kBAAkB,EAAS,qBAAqB,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,EAAE;iBACjE;aACF;SACF;KACF;IAED,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED,SAAgB,oBAAoB,CAAC,aAA4B;IAC/D,OAAO,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAf,CAAe,CAAC,CAAC;AAC/E,CAAC;AAFD,oDAEC","sourcesContent":["import { VersionNumber } from '../JsApiInternalContract';\nimport { IdentityVersionConverter } from './IdentityVersionConverter';\nimport { InternalContractVersionConverter } from './InternalContractVersionConverter';\nimport { StackingVersionConverter } from './StackingVersionConverter';\nimport * as Translations from './VersionTranslations';\nimport {\n  DowngradeFlipboardZoneID,\n  DowngradeWorksheetFomatting175,\n  DowngradeWorksheetFomattingNotification175,\n  DowngradeWorksheetNames,\n} from './VersionTranslations';\n\n/**\n * @returns true if lhs < rhs (ignoring fix number)\n * @param lhs\n * @param rhs\n */\nexport function VersionLessThan(lhs: VersionNumber, rhs: VersionNumber): boolean {\n  if (lhs.major > rhs.major) {\n    return false;\n  }\n  if (lhs.major < rhs.major) {\n    return true;\n  }\n  return lhs.minor < rhs.minor;\n}\n\n/**\n * @returns true if lhs == rhs (ignoring fix number)\n * @param lhs\n * @param rhs\n */\nexport function VersionEqualTo(lhs: VersionNumber, rhs: VersionNumber): boolean {\n  return lhs.major === rhs.major && lhs.minor === rhs.minor;\n}\n\nexport interface MajorMinorTranslators<T> {\n  [major: number]: { [minor: number]: Array<T> };\n}\n\n// A mapping from an older client version of internal-contract to the current platform version of this contract.\n// Each version bump can have an array of translations to perform in order. Notice that this is\n// different than the major upgrades/downgrades above because it handles both major and minor version changes.\n// Also please note: downgradeExecuteCall is handled on the client/external side rather than platform side.\n// When updating the major or minor version of our internal-contract, you will need to update these data structures.\n// * If there are translations to add, add them to the version to \"upgrade from\" or \"downgrade to\".\nexport const ExecuteMinorUpgrades: MajorMinorTranslators<Translations.UpgradeExecuteCall> = {\n  1: {\n    9: [], // Note that we put upgrades from 1.9 to 1.10 in the [1][9] bucket\n  },\n};\n\nexport const ExecuteMinorDowngrades: MajorMinorTranslators<Translations.DowngradeExecuteReturn> = {\n  1: {\n    5: [DowngradeWorksheetNames],\n    9: [],\n    175: [DowngradeWorksheetFomatting175],\n  },\n};\n\nexport const NotificationMinorDowngrades: MajorMinorTranslators<Translations.DowngradeNotification> = {\n  1: {\n    9: [],\n    10: [DowngradeFlipboardZoneID],\n    175: [DowngradeWorksheetFomattingNotification175],\n  },\n};\n\n/**\n * Creates a new InternalContractVersionConverter which has the ability to upgrade and downgrade the contract\n * between the two versions, which are specified. If externalMajorVersion is greater than platformMajorVersion,\n * an error will be thrown because we won't know how to do those conversions.\n * This converter can handle both major and minor updates when the platform version is greater than external version.\n *\n * @param externalVersion VersionNumber of the internal api which the external module is using\n * @param platformVersion VersionNumber of the internal api which the platform is using\n */\nexport function CreateVersionConverter(externalVersion: VersionNumber, platformVersion: VersionNumber): InternalContractVersionConverter {\n  return CreateVersionConverterWithTranslators(\n    externalVersion,\n    platformVersion,\n    ExecuteMinorUpgrades,\n    ExecuteMinorDowngrades,\n    NotificationMinorDowngrades,\n  );\n}\n\n/**\n * Implementation of CreateVersionConverter. This function takes the upgrade, downgrade, and\n * notification arrays so that all the logic can be tested.\n *\n * @param externalVersion VersionNumber of the internal api which the external module is using\n * @param platformVersion VersionNumber of the internal api which the platform is using\n * @param upgrades MajorMinorTranslators for upgrades\n * @param downgrades MajorMinorTranslators for downgrades\n * @param notificationDowngrades MajorMinorTranslators for notification downgrades\n */\nexport function CreateVersionConverterWithTranslators(\n  externalVersion: VersionNumber,\n  platformVersion: VersionNumber,\n  upgrades: MajorMinorTranslators<Translations.UpgradeExecuteCall>,\n  downgrades: MajorMinorTranslators<Translations.DowngradeExecuteReturn>,\n  notificationDowngrades: MajorMinorTranslators<Translations.DowngradeNotification>,\n): InternalContractVersionConverter {\n  const externalMajorVersion: number = externalVersion.major;\n  const externalMinorVersion: number = externalVersion.minor;\n  const platformMajorVersion: number = platformVersion.major;\n\n  if (externalMajorVersion > platformMajorVersion) {\n    throw new Error(`External version must be less than or equal to platform version.\n    externalMajorVersion=${externalMajorVersion} platformMajorVersion=${platformMajorVersion}`);\n  }\n\n  // If we are using the exact same versions (major.minor), just use the identity converter\n  if (VersionEqualTo(externalVersion, platformVersion)) {\n    return new IdentityVersionConverter();\n  }\n\n  // Walk the span between the versions we have here and collect the upgrade and downgrades necessary\n  const neededExecuteUpgrades: Array<Translations.UpgradeExecuteCall> = GetNeededTranslations(\n    externalMajorVersion,\n    platformMajorVersion,\n    externalMinorVersion,\n    upgrades,\n  );\n\n  const neededExecuteDowngrades: Array<Translations.DowngradeExecuteReturn> = GetNeededTranslations(\n    externalMajorVersion,\n    platformMajorVersion,\n    externalMinorVersion,\n    downgrades,\n  );\n\n  const neededNotificationDowngrades: Array<Translations.DowngradeNotification> = GetNeededTranslations(\n    externalMajorVersion,\n    platformMajorVersion,\n    externalMinorVersion,\n    notificationDowngrades,\n  );\n\n  // We want to apply the downgrades in reverse order in case of dependencies between them\n  neededExecuteDowngrades.reverse();\n  neededNotificationDowngrades.reverse();\n\n  return StackingVersionConverter.fromData(\n    externalVersion,\n    platformVersion,\n    neededExecuteUpgrades,\n    neededExecuteDowngrades,\n    neededNotificationDowngrades,\n  );\n}\n\nfunction GetNeededTranslations<T>(\n  externalMajorVersion: number,\n  platformMajorVersion: number,\n  externalMinorVersion: number,\n  majorMinorTranslators: MajorMinorTranslators<T>,\n): Array<T> {\n  const neededTranslations: Array<T> = [];\n\n  for (let major = externalMajorVersion; major <= platformMajorVersion; major++) {\n    if (major in majorMinorTranslators) {\n      const start = major === externalMajorVersion ? externalMinorVersion : 0;\n      const maximumMinorVersion = GetMaximumMinorIndex(Object.keys(majorMinorTranslators[major]));\n      for (let minor = start; minor <= maximumMinorVersion; minor++) {\n        if (minor in majorMinorTranslators[major]) {\n          neededTranslations.push(...majorMinorTranslators[major][minor]);\n        }\n      }\n    }\n  }\n\n  return neededTranslations;\n}\n\nexport function GetMaximumMinorIndex(minorVersions: Array<string>): number {\n  return minorVersions.map((a) => Number(a)).reduce((a, b) => (a > b ? a : b));\n}\n"]}