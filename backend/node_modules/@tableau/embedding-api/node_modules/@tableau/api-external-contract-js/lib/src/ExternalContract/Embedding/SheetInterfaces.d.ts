import { Annotation } from '../Shared/AnnotationInterfaces';
import { DataSource, LogicalTable } from '../Shared/DataSourceInterfaces';
import { Column, DataTable, DataTableReader, GetSummaryDataOptions, GetUnderlyingDataOptions } from '../Shared/DataTableInterfaces';
import { Filter, FilterOptions, RangeFilterOptions, RelativeDateFilterOptions } from '../Shared/FilterInterfaces';
import { DashboardObjectType, FilterUpdateType, SelectionUpdateType, SheetType } from '../Shared/Namespaces/Tableau';
import { MarkInfo, MarksCollection, SelectionCriteria } from '../Shared/SelectionInterfaces';
import { Size } from '../Shared/SheetInterfaces';
import { VisualSpecification } from '../Shared/VisualModelInterface';
import { ApiMenuType, SheetSizeBehavior } from './Enums';
import { StoryPoint } from './StoryInterfaces';
import { Workbook } from './WorkbookInterface';
export interface SheetSize {
    /**
     * The sizing method for a sheet. The value must be one of the following: Automatic, Exactly, Range, AtLeast, and AtMost.
     * Exactly, Range, AtLeast, and AtMost are used in combination with minSize or maxsize.
     */
    readonly behavior: SheetSizeBehavior;
    /**
     *  The minimum size of the sheet. This is only defined when behavior is Exactly, Range, or AtLeast.
     */
    readonly minSize?: Size;
    /**
     *  The maximum size of the sheet. This is only defined when behavior is Exactly, Range or AtMost.
     */
    readonly maxSize?: Size;
}
export interface Sheet {
    /**
     * @returns The name of the sheet.
     */
    readonly name: string;
    /**
     * @returns The type of the sheet.
     */
    readonly sheetType: SheetType;
    /**
     * @returns A value indicating whether the sheet is the currently active sheet.
     */
    readonly isActive: boolean;
    /**
     * @returns  A value indicating whether the sheet is hidden (true) or visible (false) in the UI.
     * Note that if the entire tab control is hidden, it does not affect the state of this flag.
     * This sheet may still report that it is visible even when the tabs control is hidden.
     */
    readonly isHidden: boolean;
    /**
     * @returns The index of the sheet within the published tabs. Note that hidden tabs are still
     * counted in the ordering, as long as they are published.
     */
    readonly index: number;
    /**
     * @returns the URL for this sheet.
     */
    readonly url: string;
    /**
     * @returns The size information that the author specified when publishing the workbook.
     */
    readonly size: SheetSize;
    /**
     * @returns The workbook containing this sheet
     */
    readonly workbook: Workbook;
    /**
     * Sets the size information of a sheet. Note that if the sheet is a Worksheet, only SheetSizeBehavior.Automatic
     * is allowed since you can't actually set a Worksheet to a fixed size.
     */
    changeSizeAsync(sheetSize: SheetSize): Promise<SheetSize>;
}
/**
 * Information needed to insert and display an external context menu item.
 */
export interface ContextMenuOptions {
    readonly displayName: string;
}
/**
 * A query state for use with Tableau Pulse.
 * @ignore
 */
export interface EmbeddingAbstractQuery {
    abstractQuery: string;
}
/**
 * The viz state and data model.
 * @ignore
 */
export interface EmbeddingVizStateWithDataModel {
    vizStateWithDataModel: string;
}
/**
 * A worksheet for use with Tableau Pulse.
 * @ignore
 */
export interface AuthoringWorksheet {
    /**
     * Gets the abstract query and data model from the VizClient.
     *
     * @returns {Promise<EmbeddingAbstractQuery>} - the currently active sheet (the active tab).
     * @deprecated
     * @ignore
     */
    getAbstractQueryWithDataModelAsync(): Promise<EmbeddingAbstractQuery>;
    /**
     * Gets the viz state and data model from the VizClient.
     *
     * @returns {Promise<EmbeddingVizStateWithDataModel>} - the viz state and data model for the currently active sheet (the active tab).
     * @ignore
     */
    getVizStateWithDataModelAsync(): Promise<EmbeddingVizStateWithDataModel>;
    /**
     * Sets the viz state and data model in the VizClient.
     * @param {EmbeddingVizStateWithDataModel} vizStateWithDataModel - The viz state with data model.
     * @returns {Promise<void>} Promise which resolves to void.
     * @ignore
     */
    setVizStateWithDataModelAsync(vizStateWithDataModel: EmbeddingVizStateWithDataModel): Promise<void>;
}
export interface Worksheet extends Sheet {
    /**
     * @returns  The dashboard object to which this worksheet belong. If the worksheet is not on a dashboard, it returns null.
     */
    readonly parentDashboard: Dashboard | null;
    /**
     * @returns  The {@link StoryPoint} object to which this worksheet belongs. If the worksheet is not in a story, it returns null.
     */
    readonly parentStoryPoint: StoryPoint | null;
    /**
     * Gets the data sources for this worksheet. Note that calling this method might negatively impact performance
     *  and responsiveness of the viz that you are embedding. The method is partly
     *  asynchronous but includes some serial operations.
     *
     * @returns The primary data source and all of the secondary data sources for this worksheet.
     *          By convention the first data source in the array is the primary.
     *
     * The following example shows how you might find a specific data source of a worksheet,
     * using the `getDataSourcesAsync()` method. You could then call the `getLogicalTablesAsync()` method
     * to get the logical tables in the data source, and then use the either the `DataSource` or the
     * `Worksheet` to get the underlying table data.
     *
     * Use `await` only inside an Async function
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    let dataSources = await vizActiveSheet.getDataSourcesAsync();
     *    console.log(dataSources[0].name);
     *    let dataSource = dataSources.find(datasource => datasource.name === "Sample - Superstore");
     *    // process the dataSource
     * }
     * ```
     *
     */
    getDataSourcesAsync(): Promise<Array<DataSource>>;
    /**
     * Gets the summary data table for a worksheet.
     * Warning: getSummaryDataAsync can fail with a worksheet with many rows of data and is now deprecated.
     *
     * @param options  Collection of options to change the behavior of the call.
     * @returns        A data table containing the summary data for the worksheet.
     *
     * @deprecated Use getSummaryDataReaderAsync to avoid failures with many rows of data.
     *
     * Example shows how to replace unsafe usage of `getSummaryDataAsync` with
     * `getSummaryDataReaderAsync` and `getAllPagesAsync` assuming less than 4,000,000
     * rows of data.
     *
     *```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *   const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();
     *   const dataTable = await dataTableReader.getAllPagesAsync();
     *   await dataTableReader.releaseAsync();
     *   // ... process data table ...
     * }
     *```
     *
     * Example shows how to replace unsafe usage of `getSummaryDataAsync` with
     * `getSummaryDataReaderAsync` and `getPageAsync` and work with individual
     * pages.
     *```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *   const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();
     *   for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {
     *     const dataTablePage = await dataTableReader.getPageAsync(currentPage);
     *     // ... process current page ....
     *   }
     *   await dataTableReader.releaseAsync();
     * }
     *```
     */
    getSummaryDataAsync(options?: GetSummaryDataOptions): Promise<DataTable>;
    /**
     * Gets a summary data table reader for this worksheet.
     * Only one active DataTableReader for summary data is supported.
     *
     * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.
     * @param options  Collection of options to change the behavior of the reader.
     * @returns        A data table reader to access the summary data for the worksheet.
     *
     *  Example showing the methods to get and use the summary data reader for all rows in a worksheet.
     *  Use `await` only inside an Async function
     *```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *     const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();
     *     for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {
     *         const dataTablePage = await dataTableReader.getPageAsync(currentPage);
     *         // ... process current page ....
     *     }
     *     await dataTableReader.releaseAsync();
     * }
     *```
     */
    getSummaryDataReaderAsync(pageRowCount?: number, options?: GetSummaryDataOptions): Promise<DataTableReader>;
    /**
     * Gets the columns that are returned with `getSummaryDataAsync` or `getSummaryDataReaderAsync`.
     * The columns are sorted in the order that they appear in the view or in the View Data window.
     * Note that `getSummaryDataReaderAsync` returns the summary data sorted with the columns
     * in alphabetical (ascending) order. You can use  method to determine the view order..
     *
     * @returns The array of columns that describe the data in the worksheet.
     */
    getSummaryColumnsInfoAsync(): Promise<Array<Column>>;
    /**
     * Gets the underlying data table for this worksheet.
     *
     * @param options  Collection of options to change the behavior of the call.
     * @returns        A data table containing the underlying data for the worksheet.
     *
     *
     * You can use the `GetUnderlyingDataOptions.maxRows` property to request the number of rows of data to return.
     * If unspecified (maxRows == '0'), the call to `getUnderlyingDataAsync` requests all rows in the data source.
     * Note that the maximum number of rows returned from the `getUnderlyingDataAsync()` method is limited
     * to 10,000 rows. You can use the `DataTable` property, `isTotalRowCountLimited`, to test whether there is
     * more data. A value of true indicates that the calling function requested more rows than the limit (10,000) and the
     * underlying data source contains more rows than can be returned.
     *
     * In the following example, the `getUnderlyingDataAsync()` method is used to get the underlying data for
     * a specific column in a workbook.
     * Use `await` only inside an Async function
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    let dataTable = await  vizActiveSheet.getUnderlyingDataAsync();
     *    let field = dataTable.columns.find(column => column.fieldName === "Sales");
     *    let list = [];
     *    for (let row of dataTable.data) {
     *         list.push(row[field.index].value);
     *    }
     *    let values = list.filter((el, i, arr) => arr.indexOf(el) === i);
     *    console.log(values);
     * }
     *
     * ```
     * @deprecated Use Worksheet.getUnderlyingTableDataReaderAsync or Worksheet.getUnderlyingTableDataAsync.
     *
     */
    getUnderlyingDataAsync(options?: GetUnderlyingDataOptions): Promise<DataTable>;
    /**
     * Gets the underlying logical tables used by the worksheet. The resulting logical tables are determined by the measures in the worksheet.
     * If a worksheet's data source contains multiple logical tables and the worksheet contains only measures from one logical table, this API
     * will return one logical table.
     *
     * @returns An array of logical tables corresponding to the measures referenced by the worksheet.
     * Use `await` only inside an Async function
     *
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    // Call to get the underlying logical tables used by the worksheet
     *    let underlyingTablesData = await vizActiveSheet.getUnderlyingTablesAsync();
     *    let logicalTableId = underlyingTablesData[0].id;
     *    // Use the above logicalTableId to get the underlying data on the active sheet
     *    // by calling worksheet.getUnderlyingTableDataAsync(logicalTableId)
     *    let underlyingTableDataForId = await vizActiveSheet.getUnderlyingTableDataAsync(logicalTableId);
     * }
     * ```
     */
    getUnderlyingTablesAsync(): Promise<Array<LogicalTable>>;
    /**
     * Gets the underlying data table for the given logical table id.
     * Use the `getUnderlyingTablesAsync` method to identify the logical tables.
     *
     * @param logicalTableId logical table id.
     * @param options  Collection of options to change the behavior of the call.
     * @returns        A data table containing the underlying data for the given logical table id
     *
     * You can use the `getUnderlyingDataOptions.maxRows` property to request the number of rows of data to return.
     * If unspecified (maxRows == '0'), the call to `getUnderlyingTableDataAsync` requests all rows in the logical table.
     * Note that the maximum number of rows returned from the `getUnderlyingTableDataAsync()` method is limited
     * to 10,000 rows. You can use the `DataTable` property, `isTotalRowCountLimited`, to test whether there is
     * more data. A value of true indicates that the calling function requested more rows than the limit (10,000) and the
     * underlying data source contains more rows than can be returned.
     *
     * @see getUnderlyingTableDataReaderAsync to read more than 10,000 rows.
     * ```
     * var worksheet = tableau.extensions.dashboardContent.dashboard.worksheets.find(w => w.name === "Sale Map");
     * const logicalTables = await worksheet.getUnderlyingTablesAsync();
     * const dataTable = await worksheet.getUnderlyingTableDataAsync(logicalTables[0].id)
     * // process the dataTable...
     * ```
     */
    getUnderlyingTableDataAsync(logicalTableId: string, options?: GetUnderlyingDataOptions): Promise<DataTable>;
    /**
     * Gets a underlying data table reader for the given logical table id.
     * Use the `getUnderlyingTablesAsync` method to identify the logical tables.
     * Only one active DataTableReader per logical table id is supported.
     *
     * `getUnderlyingTableDataReaderAsync` attempts to prepare all the rows of the underlying table to be read as pages.
     * However, there is a limit to the number of rows that can be prepared. The default limit is 1 million rows of data.
     * You can change the default limit with the Tableau Server (Cloud) or Tableau Desktop option: ExtensionsAndEmbeddingReaderRowLimit.
     * If the underlying table has many columns, `getUnderlyingTableDataReaderAsync` can be sped up by only requesting
     * native data values in the GetUnderlyingDataOptions.
     *
     * @param logicalTableId logical table id.
     * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.
     * @param options  Collection of options to change the behavior of the reader.
     * @returns        A data table reader to access the underlying data for the given logical table id.
     *
     * The following example shows getting the first page of underlying data.
     * Use `await` only inside an Async function
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    // Call to get the underlying logical tables used by the worksheet
     *    const underlyingTablesData = await vizActiveSheet.getUnderlyingTablesAsync();
     *    const logicalTableId = underlyingTablesData[0].id;
     *    // Use the above logicalTableId to get the underlying data reader on the active sheet
     *    const dataTableReader = await vizActiveSheet.getUnderlyingTableDataReaderAsync(logicalTableId);
     *    const page = await dataTableReader.getPageAsync(0);
     *    // ... process first page ....
     *    await dataTableReader.releaseAsync();
     * }
     * ```
     */
    getUnderlyingTableDataReaderAsync(logicalTableId: string, pageRowCount?: number, options?: GetUnderlyingDataOptions): Promise<DataTableReader>;
    /**
     * Gets the list of filters on a worksheet. Hierarchical filters are not yet supported
     * @returns A promise that resolves to the collection of filters used in this worksheet.
     */
    getFiltersAsync(): Promise<Array<Filter>>;
    /**
     * Applies the list of provided categorical filter values.
     *
     * @param fieldName      The name of the field to filter on.
     * @param values         The list of values to filter on.
     * @param updateType     The update type of this filter (add, all, remove, replace).
     * @param filterOptions  Advanced filter options (isExcludeMode).
     *
     * @returns  The field name that the filter is applied on.
     */
    applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;
    /**
     * Applies a range filter to a quantitative or date field.
     *
     * @param fieldName      The name of the field to filter on
     * @param filterOptions  Filter Options: min, max, nullOption. Atleast one of of min and max is required.
     * For applying date filters, UTC Date objects are expected. (i.e., var min = new Date(Date.UTC(1999, 0, 1)))
     * @return The field name that the filter is applied on.
     */
    applyRangeFilterAsync(fieldName: string, filterOptions: RangeFilterOptions): Promise<string>;
    /**
     * Resets existing filters on the given field.
     * Categorical filters are reset to "All," and range filters are reset to the full range.
     * Relative date filters can not be reset, consider using the applyRelativeDateFilterAsync API.
     *
     * @param fieldName  The name of the field to clear filter on.
     *
     * @returns The field to clear filter on.
     */
    clearFilterAsync(fieldName: string): Promise<string>;
    /**
     * Applies a relative date filter.
     *
     * @param fieldName The name of the field to filter on.
     * @param options   The relative date filter options (anchorDate, periodType, rangeType, rangeN). When the rangeType is LASTN or NEXTN, the rangeN is required.
     *
     * @returns  The field name that the filter is applied on.
     *
     * The following example shows how to apply a relative date filter from a worksheet.
     * ```
     *  worksheet.applyRelativeDateFilterAsync(
     *    'Order Date',
     *    {
     *      anchorDate: new Date(Date.UTC(2022, 4, 13)),
     *      periodType: PeriodType.Years,
     *      rangeType: DateRangeType.LastN,
     *      rangeN: 1,
     *    }
     *  );
     * ```
     */
    applyRelativeDateFilterAsync(fieldName: string, options: RelativeDateFilterOptions): Promise<string>;
    /**
     * Applies the list of provided hierarchial filter values.
     *
     * @param fieldName      The name of the field to filter on.
     * @param values         The list of values or levels to filter on.
     * @param updateType     The update type of this filter (add, all, remove, replace).
     * @param filterOptions  Advanced filter options (isExcludeMode).
     *
     * @returns  The field name that the filter is applied on.
     *
     */
    applyHierarchicalFilterAsync(fieldName: string, values: Array<string> | HierarchicalLevels, updateType: FilterUpdateType, options: FilterOptions): Promise<string>;
    /**
     * Clears selected marks in the current worksheet.
     *
     * @return Empty promise that resolves when the selection has been cleared.
     *
     * The following example assumes that you have some marks already selected in the worksheet. After it has run,
     * you should have no marks selected, and you should see the console message.
     * Use `await` only inside an Async function
     *
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    // clear selected marks
     *    await vizActiveSheet.clearSelectedMarksAsync();
     *    console.log('Your marks selection has been cleared!');
     * }
     * ```
     */
    clearSelectedMarksAsync(): Promise<void>;
    /**
     * Gets the data for the marks which are currently selected on the worksheet.
     * If there are no marks currently selected, an empty model is returned.
     *
     * @returns The marks that are selected.
     *
     * Use `await` only inside an Async function
     *
     * ```
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "worksheet") {
     *    // Call to get the selected marks for the worksheet
     *    let selectedMarks = await vizActiveSheet.getSelectedMarksAsync();
     *    // Get the first DataTable for our selected marks (usually there is just one)
     *    const dataTableName = selectedMarks.data[0];
     *    // Map the data into a format for display, etc.
     * }
     * ```
     *
     *
     */
    getSelectedMarksAsync(): Promise<MarksCollection>;
    /**
     * Selects the marks by value, using the SelectionCriteria interface.
     * This is intended for manual construction of the desired selections.
     *
     * @param selections   A list of criteria for which marks to select.
     * @param updateType          The type of selection to make: add, remove, or replace.
     *
     * @returns                   Empty promise that resolves when the selection is complete.
     *
     * The following example shows how you might call this method using state names as the `SelectionCriteria`.
     * The `SelectionUpdateType` is replace (`SelectionUpdateType.Replace`), so these values replace
     * the marks that are currently selected.
     *
     * ```
     *    worksheet.selectMarksByValueAsync([{
     *         fieldName: 'State',
     *         value: ['Texas', 'Washington', 'California']
     *     }], SelectionUpdateType.Replace );
     *
     * ```
     *
     */
    selectMarksByValueAsync(selections: Array<SelectionCriteria>, updateType: SelectionUpdateType): Promise<void>;
    /**
     * Add an annotation to the specified mark.
     * This is intended to be passed a MarkInfo object received from a DataTable.
     * MarkInfo can be found in the DataTable returned from getSelectedMarksAsync.
     *
     * @param mark            The mark to annotate.
     * @param annotationText  The text to display in the annotation.
     *
     * @returns Empty promise that resolves when the annotation is complete.
     *
     * The following example shows how you might call this method using a MarkInfo object.
     *
     * ```
     *    const markCollection = await worksheet.getSelectedMarksAsync();
     *    const markToAnnotate = marksCollection.data[0].marksInfo[0];
     *    await worksheet.annotateMarkAsync(markToAnnotate, 'Manufacturing line #2 shutdown triggered');
     * ```
     *
     */
    annotateMarkAsync(mark: MarkInfo, annotationText: string): Promise<void>;
    /**
     * Retrieves a list of the annotations in the worksheet.
     *
     * @returns           A list annotations in the worksheet.
     *
     * The following example shows how you might call this method.
     *
     * ```
     *    let annotations = await worksheet.getAnnotationsAsync();
     *    console.log(annotations);
     * ```
     *
     */
    getAnnotationsAsync(): Promise<Array<Annotation>>;
    /**
     * Removes the corresponding annotation from the worksheet it belongs to.
     * This is intended to be passed an Annotation object received from getAnnotationsAsync.
     *
     * @param annotation  The annotation to remove.
     * @returns           Empty promise that resolves when the annotation is removed.
     *
     * The following example shows how you might call this method using an annotation object.
     *
     * ```
     *    for (const annotation of annotations) {
     *      await worksheet.removeAnnotationAsync(annotation);
     *    }
     * ```
     *
     */
    removeAnnotationAsync(annotation: Annotation): Promise<void>;
    /**
     * Adds external context menu item into location defined by targetMenu input parameter.
     *
     * Calling this function does not have immediate affect, it just registers new menu item.
     * When the corresponding context menu is later shown, the new menu item is also rendered there.
     *
     * The return value of this function is the unique identifier for the newly inserted context menu item.
     *
     * When the user clicks the new context menu item, a TableauEvent is raised.
     * Each targetMenu parameter will have a different event type.
     * The unique identifier could be used to distinguish different menu items that have the same event type.
     *
     * @param targetMenu Defines where to insert the new external menu item.
     * @param config Provides configuration information for new external menu item.
     * @returns Unique identifier for newly inserted context menu item.
     */
    appendContextMenuAsync(targetMenu: ApiMenuType, config: ContextMenuOptions): Promise<string>;
    /**
     * Removes the external context menu item inserted by the appendContextMenuAsync method.
     *
     * The parameter menuItemId specifies the menu item to remove and is the return
     * value from the appendContextMenuAsync method.
     *
     * Once this function is called, menu item identified by menuItemId won't be rendered to the user
     * in corresponding context menu.
     *
     * @param targetMenu Defines where to remove new external menu item.
     * @param menuItemId Unique identifier of external context menu item that user wants to remove.
     */
    removeContextMenuAsync(targetMenu: ApiMenuType, menuItemId: string): Promise<void>;
    /**
     * Executes the external context menu item inserted by the appendContextMenuAsync method.
     *
     * The parameter menuItemId specifies the menu item to execute and is the return
     * value from the appendContextMenuAsync method.
     *
     * Once this function is called, menu item identified by menuItemId will be executed.
     *
     * @param targetMenu Defines where to execute new external menu item.
     * @param menuItemId Unique identifier of external context menu item that user wants to execute.
     */
    executeContextMenuAsync(targetMenu: ApiMenuType, menuItemId: string): Promise<void>;
    /**
     * Sets the displayed header for the external context menu.
     *
     * The parameter menuHeader specifies the header to be displayed.
     *
     * Once this function is called, menuHeader will be rendered to the user as the header
     * for corresponding context menu. If not called, a default header will be displayed.
     *
     * @param targetMenu Specifies the location of the external context menu.
     * @param menuHeader Defines a header string to be displayed for the menu.
     * @param menuDescription Defines a description of the menu to be displayed in a tooltip
     */
    renameContextMenuAsync(targetMenu: ApiMenuType, menuHeader: string, menuDescription: string): Promise<void>;
    /**
     * Returns the visual specification for the worksheet, which can be used to get
     * the mappings from fields to encodings backing the visual within the worksheet
     *
     * @returns Promise containing the VisualSpecification
     */
    getVisualSpecificationAsync(): Promise<VisualSpecification>;
}
export interface Dashboard extends Sheet {
    /**
     * @returns  The collection of objects contained in the dashboard.
     *
     */
    readonly objects: Array<DashboardObject>;
    /**
     *
     *  This is a helper method and is equivalent to looping
     *  through all of the objects in a dashboard and collecting all of the objects
     *  whose type is `worksheet`. You can use this property to iterate
     *  through all of the worksheets in the dashboard.
     *
     * @returns  The collection of worksheets contained in the dashboard.
     *
     * The following example uses the JavaScript `forEach()` method to traverse
     * the worksheets in the dashboard.
     * <br/>
     *
     *
     * ```
     *
     * let vizActiveSheet = viz.workbook.activeSheet;
     * if (vizActiveSheet.sheetType === "dashboard") {
     *    vizActiveSheet.worksheets.forEach(function (worksheet) {
     *    // do something with the worksheets..
     *    })
     * }
     *
     * ```
     */
    readonly worksheets: Array<Worksheet>;
    /**
     * @returns  Returns the {@link StoryPoint} object to which this Dashboard belongs. If the Dashboard doesn't belong to a story, it returns null.
     */
    readonly parentStoryPoint: StoryPoint | null;
    /**
     * @returns The collection of filters used on the dashboard
     */
    getFiltersAsync(): Promise<Array<Filter>>;
    /**
     * Applies a simple categorical filter (non-date) to the dashboard.
     * This method is similar to the method used for worksheets, but applies the filter to all the worksheets in the dashboard that have that same field.
     * Note that the filter is ignored by a worksheet if the worksheet doesn't have the relevant field in its data source.
     *
     * @param fieldName      The name of the field to filter on.
     * @param values         The list of values to filter on.
     * @param updateType     The update type of this filter (add, all, remove, replace).
     * @param filterOptions  Advanced filter options (isExcludeMode).
     *
     * @returns  The field name that the filter is applied on.
     */
    applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;
}
/**
 * An object of a dashboard.
 */
export interface DashboardObject {
    /**
     * @returns The Dashboard object that contains this object.
     */
    readonly dashboard: Dashboard;
    /**
     * @returns  What the object represents.
     */
    readonly type: DashboardObjectType;
    /**
     * @returns  The coordinates relative to the top-left corner of the dashboard containing this object.
     */
    readonly position: Point;
    /**
     * @returns  The size of the object.
     */
    readonly size: Size;
    /**
     * @returns  If type returns WORKSHEET, this returns a Worksheet object, undefined otherwise.
     */
    readonly worksheet: Worksheet | undefined;
    /**
     * @returns The name of the dashboard object. This is the name given to the object during authoring.
     */
    readonly name: string;
    /**
     * @returns True if the object is floating in the dashboard.
     */
    readonly isFloating: boolean;
    /**
     * @returns True if the object is visible.
     */
    readonly isVisible: boolean;
    /**
     * @returns  The id of the dashboard object
     */
    readonly id: number;
}
/**
 * Represents an x/y coordinate in pixels.
 */
export interface Point {
    /**
     * @returns  X coordinate of point.
     */
    readonly x: number;
    /**
     * @returns  Y coordinate of point.
     */
    readonly y: number;
}
export interface SheetInfo {
    /**
     * @returns the name of the sheet.
     */
    readonly name: string;
    /**
     * @returns the index of the sheet within the published tabs. Note that hidden tabs are still counted in the ordering,
     * as long as they are published.
     */
    readonly index: number;
    /**
     * @returns a value indicating whether the sheet is the currently active sheet.
     * Due to a technical limitation, this will always return false if the object is a Worksheet instance that is part of a Dashboard.
     */
    readonly isActive: boolean;
    /**
     * @returns a value indicating whether the sheet is hidden in the UI.
     * Note that if the entire tab control is hidden, it does not affect the state of this flag.
     * This sheet may still report that it is visible even when the tabs control is hidden.
     */
    readonly isHidden: boolean;
    /**
     * @returns The type of the sheet. SheetType is an enum with the following values: WORKSHEET, DASHBOARD and STORY.
     */
    readonly sheetType: SheetType;
    /**
     * @returns The Workbook to which this Sheet belongs.
     */
    readonly workbook: Workbook;
    /**
     * @returns The URL for this sheet.
     */
    readonly url: string;
    /**
     * @returns The size information that the author specified when publishing the workbook.
     */
    readonly size: SheetSize;
}
/**
 * Levels to apply to a hierarchical filter
 */
export interface HierarchicalLevels {
    levels: Array<string>;
}
//# sourceMappingURL=SheetInterfaces.d.ts.map