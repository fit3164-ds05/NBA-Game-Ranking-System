{"version":3,"file":"SheetInterfaces.js","sourceRoot":"","sources":["../../../../src/ExternalContract/Extensions/SheetInterfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { Annotation } from '../Shared/AnnotationInterfaces';\nimport { DataSource, LogicalTable } from '../Shared/DataSourceInterfaces';\nimport { Column, DataTable, DataTableReader, GetSummaryDataOptions, GetUnderlyingDataOptions } from '../Shared/DataTableInterfaces';\nimport { Filter, FilterOptions, RangeFilterOptions, RelativeDateFilterOptions } from '../Shared/FilterInterfaces';\nimport {\n  DashboardObjectType,\n  DashboardObjectVisibilityType,\n  EncodingType,\n  FilterUpdateType,\n  ReplaySpeedType,\n  SelectOptions,\n  SelectionUpdateType,\n  SheetType,\n  ZoneVisibilityType,\n} from '../Shared/Namespaces/Tableau';\nimport { MarkInfo, MarksCollection, SelectionCriteria, TooltipContext } from '../Shared/SelectionInterfaces';\nimport { Size } from '../Shared/SheetInterfaces';\nimport { VisualSpecification } from '../Shared/VisualModelInterface';\nimport { WorksheetFormatting } from '../Shared/WorkbookFormattingInterfaces';\nimport { EventListenerManager } from './EventInterface';\nimport { Parameter } from './ParameterInterfaces';\n\nexport interface Sheet extends EventListenerManager {\n  /**\n   * @returns  The name of the sheet.\n   */\n  readonly name: string;\n\n  /**\n   * @returns  The type of the sheet.\n   */\n  readonly sheetType: SheetType;\n\n  /**\n   * Searches for a parameter with the given name.\n   *\n   * @param parameterName   The name of the parameter to find.\n   * @returns               The parameter with the given name, or undefined if it does not exist.\n   */\n  findParameterAsync(parameterName: string): Promise<Parameter | undefined>;\n\n  /**\n   * @returns  Size of the sheet.\n   */\n  readonly size: Size;\n\n  /**\n   * @returns  A collection of all the Tableau parameters that are used in this workbook.\n   */\n  getParametersAsync(): Promise<Array<Parameter>>;\n}\n\nexport interface Worksheet extends Sheet {\n  /**\n   * @returns  The dashboard object to which this worksheet belongs.\n   * @category Dashboard Extensions\n   */\n  readonly parentDashboard: Dashboard;\n\n  /**\n   * @returns  The background color of the worksheet.\n   * @category Viz Extensions\n   */\n  readonly backgroundColor: string;\n\n  /**\n   * @returns  Worksheet level formatting.\n   * @category Viz Extensions\n   */\n  readonly formatting: WorksheetFormatting;\n\n  /**\n   * Applies the list of provided categorical filter values.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   */\n  applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;\n\n  /**\n   * Applies a range filter to a quantitative or date field.\n   *\n   * @param fieldName      The name of the field to filter on\n   * @param filterOptions  Filter Options: min, max, nullOption. At least one of of min and max is required.\n   * For applying date filters, UTC Date objects are expected (that is, `var min = new Date(Date.UTC(1999, 0, 1))`).\n   * @return The field name that the filter is applied on.\n   * @since 1.10.0 Errors will now be thrown for invalid fields or values.\n   */\n  applyRangeFilterAsync(fieldName: string, filterOptions: RangeFilterOptions): Promise<string>;\n\n  /**\n   * Resets existing filters on the given field.\n   * Categorical filters are reset to \"All,\" and range filters are reset to the full range\n   * Relative date filters can not be reset, consider using the applyRelativeDateFilterAsync API.\n   *\n   * @param fieldName  The name of the field to clear filter on.\n   *\n   * @returns The field to clear filter on.\n   */\n  clearFilterAsync(fieldName: string): Promise<string>;\n\n  /**\n   * Applies the list of provided hierarchial filter values.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values or levels to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   * @since 1.10.0 and Tableau 2022.3\n   *\n   */\n  applyHierarchicalFilterAsync(\n    fieldName: string,\n    values: Array<string> | HierarchicalLevels,\n    updateType: FilterUpdateType,\n    options: FilterOptions,\n  ): Promise<string>;\n\n  /**\n   * Applies a relative date filter.\n   *\n   * @param fieldName The name of the field to filter on.\n   * @param options   The relative date filter options (anchorDate, periodType, rangeType, rangeN). When the rangeType is LASTN or NEXTN, the rangeN is required.\n   *\n   * @returns  The field name that the filter is applied on.\n   * @since version 1.9.0 and Tableau 2022.2\n   *\n   * The following example shows how to apply a relative date filter from a worksheet.\n   * ```\n   *  worksheet.applyRelativeDateFilterAsync(\n   *    'Order Date',\n   *    {\n   *      anchorDate: new Date(Date.UTC(2022, 4, 13)),\n   *      periodType: PeriodType.Years,\n   *      rangeType: DateRangeType.LastN,\n   *      rangeN: 1,\n   *    }\n   *  );\n   * ```\n   */\n  applyRelativeDateFilterAsync(fieldName: string, options: RelativeDateFilterOptions): Promise<string>;\n\n  /**\n   * Gets the data sources for this worksheet. Note that calling this method might negatively impact performance\n   *  and responsiveness of the viz that your extension is added to. The method is not entirely\n   *  asynchronous and includes some serial operations.\n   *\n   * @returns The primary data source and all of the secondary data sources for this worksheet.\n   *          By convention the first data source in the array is the primary.\n   *\n   * The following example shows how you might find a specific data source of a worksheet,\n   * using the `getDataSourcesAsync()` method. The example then chains the data source returned in the promise\n   * to a call to the `getUnderlyingDataAsync()` method to access the data table.\n   * ```\n   * worksheet.getDataSourcesAsync().then(datasources => {\n   *   dataSource = datasources.find(datasource => datasource.name === \"Sample - Superstore\");\n   *   return dataSource.getUnderlyingDataAsync();\n    }).then(dataTable => {\n         // process the dataTable...\n       });\n   *\n   * ```\n\n   *\n   */\n  getDataSourcesAsync(): Promise<Array<DataSource>>;\n\n  /**\n   * Gets the list of filters on a worksheet. Hierarchical filters are not yet supported\n   * @returns A promise that resolves to the collection of filters used in this worksheet.\n   *\n   *\n   */\n  getFiltersAsync(): Promise<Array<Filter>>;\n\n  /**\n   * Gets the data for the marks which are currently highlighted on the worksheet.\n   * If there are no marks currently highlighted, an empty model is returned.\n   *\n   * @returns The marks which are selected.\n   */\n  getHighlightedMarksAsync(): Promise<MarksCollection>;\n\n  /**\n   * Gets the data for the marks which are currently selected on the worksheet.\n   * If there are no marks currently selected, an empty model is returned.\n   *\n   * @returns The marks that are selected.\n   *\n   *\n   *\n   * ```\n   * // Call to get the selected marks for the worksheet\n   * worksheet.getSelectedMarksAsync().then(function (marks) {\n   *   // Get the first DataTable for our selected marks (usually there is just one)\n   *   const worksheetData = marks.data[0];\n   *\n   *   // Map the data into a format for display, etc.\n   *\n   * });\n   * ```\n   *\n   *\n   */\n  getSelectedMarksAsync(): Promise<MarksCollection>;\n\n  /**\n   * Gets the summary data table for this worksheet.\n   * Warning: getSummaryDataAsync can fail with a worksheet with many rows of data and is now deprecated.\n   *\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the summary data for the worksheet.\n   *\n   * @deprecated since 1.10.0 Use getSummaryDataReaderAsync to avoid failures with many rows of data.\n   *\n   * ---\n   * Note: The `getSummaryDataAsync` and `getSummaryDataReaderAsync` methods return the data that is currently\n   * in the viz, with parameters, calculated fields, and sorting applied. To access full data, that is\n   * the underlying data without the additional fields and processing you have added in Tableau, use\n   * the {@link Worksheet.getUnderlyingTableDataAsync} and {@link Worksheet.getUnderlyingTableDataReaderAsync} methods.\n   * ---\n   *\n   * The following example shows how to replace unsafe usage of `getSummaryDataAsync` with\n   * `getSummaryDataReaderAsync` and `getAllPagesAsync`, assuming you have less than 4,000,000\n   * rows of data.\n   * </br>\n   *```\n   * const dataTableReader = await worksheet.getSummaryDataReaderAsync();\n   * const dataTable = await dataTableReader.getAllPagesAsync();\n   * await dataTableReader.releaseAsync();\n   * // ... process data table ...\n   *```\n   * </br>\n   *\n   * The following example shows how to replace unsafe usage of `getSummaryDataAsync` with\n   * `getSummaryDataReaderAsync` and `getPageAsync` and work with individual\n   * pages.\n   *\n   * </br>\n   *\n   *```\n   * const dataTableReader = await worksheet.getSummaryDataReaderAsync();\n   * for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {\n   *   const dataTablePage = await dataTableReader.getPageAsync(currentPage);\n   *   // ... process current page ....\n   * }\n   * await dataTableReader.releaseAsync();\n   *```\n   */\n  getSummaryDataAsync(options?: GetSummaryDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets a summary data table reader for this worksheet.\n   * Only one active DataTableReader for summary data is supported.\n   *\n   * ---\n   * Note: The `getSummaryDataAsync` and `getSummaryDataReaderAsync` methods return the data that is currently\n   * in the viz, with parameters, calculated fields, and sorting applied. To access full data, that is\n   * the underlying data without the additional fields and processing you have added in Tableau, use\n   * the {@link Worksheet.getUnderlyingTableDataAsync} and {@link Worksheet.getUnderlyingTableDataReaderAsync} methods.\n   * ---\n   *\n   * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.\n   * @param options  Collection of options to change the behavior of the reader.\n   * @returns        A data table reader to access the summary data for the worksheet.\n   *\n   * The following example shows the methods to get and use the summary data reader for all rows in a worksheet.\n   *```\n   * const dataTableReader = await worksheet.getSummaryDataReaderAsync();\n   * for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {\n   *   let dataTablePage = await dataTableReader.getPageAsync(currentPage);\n   *   // ... process current page ....\n   * }\n   * await dataTableReader.releaseAsync();\n   *```\n   */\n  getSummaryDataReaderAsync(pageRowCount?: number, options?: GetSummaryDataOptions): Promise<DataTableReader>;\n\n  /**\n   * Gets the columns that are returned with `getSummaryDataAsync`.\n   *\n   * @returns The array of columns that describe the data in the worksheet.\n   * @since 1.5.0\n   */\n  getSummaryColumnsInfoAsync(): Promise<Array<Column>>;\n\n  /**\n   * Gets the underlying data table for this worksheet.\n   *\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the underlying data for the worksheet.\n   *\n   *\n   * @deprecated Use {@link Worksheet.getUnderlyingTableDataReaderAsync} or {@link Worksheet.getUnderlyingTableDataAsync}.\n   */\n  getUnderlyingDataAsync(options?: GetUnderlyingDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets the underlying logical tables used by the worksheet. The resulting logical tables are determined by the measures in the worksheet.\n   * If a worksheet's data source contains multiple logical tables and the worksheet contains only measures from one logical table, this API\n   * will return one logical table.\n   *\n   * @since 1.4.0\n   * @returns An array of logical tables corresponding to the measures referenced by the worksheet.\n   *\n   * ```\n   * // Call to get the underlying logical tables used by the worksheet\n   * worksheet.getUnderlyingTablesAsync().then(function (logicalTables) {\n   *   // Get the first logical table's id\n   *   const logicalTableId = logicalTables[0].id;\n   *\n   *   // Use the above logicalTableId to then get worksheet's underlying data\n   *   // by calling worksheet.getUnderlyingTableDataAsync(logicalTableId)\n   *\n   * });\n   * ```\n   */\n  getUnderlyingTablesAsync(): Promise<Array<LogicalTable>>;\n\n  /**\n   * Gets the underlying data table for the given logical table id.\n   * Use the `getUnderlyingTablesAsync` method to identify the logical tables.\n   *\n   * @param logicalTableId logical table id.\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the underlying data for the given logical table id\n   * @since 1.4.0\n   *\n   * ---\n   * Note: Use the `getUnderlyingTableDataAsync` method to access the full data, that is the underlying\n   * data without the parameters, calculated fields, and processing you might have added in Tableau.\n   * To access just the data that is currently in the viz, with parameters,\n   * calculated fields, and sorting applied, use the {@link Worksheet.getSummaryDataAsync} and\n   * {@link Worksheet.getSummaryDataReaderAsync} methods.\n   * ---\n   *\n   * You can use the `getUnderlyingDataOptions.maxRows` property to request the number of rows of data to return.\n   * If unspecified (maxRows == '0'), the call to `getUnderlyingTableDataAsync` requests all rows in the logical table.\n   * Note that the maximum number of rows returned from the `getUnderlyingTableDataAsync()` method is limited\n   * to 10,000 rows. You can use the `DataTable` property, `isTotalRowCountLimited`, to test whether there is\n   * more data. A value of true indicates that the calling function requested more rows than the limit (10,000) and the\n   * underlying data source contains more rows than can be returned.\n   *\n   * @since 1.5.0 You can use the `GetUnderlyingDataOptions.includeDataValuesOption` property to optimize performance\n   * by restricting the properties included in the returned DataValues.\n   *\n   * @see getUnderlyingTableDataReaderAsync to read more than 10,000 rows.\n   * ```\n   * const logicalTables = await worksheet.getUnderlyingTablesAsync();\n   * const dataTable = await worksheet.getUnderlyingTableDataAsync(logicalTables[0].id)\n   * // process the dataTable...\n   * ```\n   */\n  getUnderlyingTableDataAsync(logicalTableId: string, options?: GetUnderlyingDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets a underlying data table reader for the given logical table id.\n   * Use the `getUnderlyingTablesAsync` method to identify the logical tables.\n   * Only one active DataTableReader per logical table id is supported.\n   *\n   * ---\n   * Note: Use the `getUnderlyingTableDataReaderAsync` method to access the full data, that is\n   * the underlying data without the parameters, calculated fields, and processing you might\n   * have added in Tableau. To access just the data that is currently in the viz, with parameters,\n   * calculated fields, and sorting applied use the {@link Worksheet.getSummaryDataAsync} and\n   * {@link Worksheet.getSummaryDataReaderAsync} methods.\n   * ---\n   *\n   * The `getUnderlyingTableDataReaderAsync` method attempts to prepare all the rows of the underlying table to be read as pages.\n   * However, there is a limit to the number of rows that can be prepared. The default limit is 1 million rows of data.\n   * You can change the default limit with the Tableau Server (Cloud) or Tableau Desktop option: ExtensionsAndEmbeddingReaderRowLimit.\n   * If the underlying table has many columns, `getUnderlyingTableDataReaderAsync` can be sped up by only requesting\n   * native data values in the GetUnderlyingDataOptions.\n   *\n   * @param logicalTableId logical table id.\n   * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.\n   * @param options  Collection of options to change the behavior of the reader.\n   * @returns        A data table reader to access the underlying data for the given logical table id.\n   *\n   * The following example shows getting the first page of underlying data.\n   * ```\n   * // Call to get the underlying logical tables used by the worksheet\n   * const underlyingTablesData = await worksheet.getUnderlyingTablesAsync();\n   * const logicalTableId = underlyingTablesData[0].id;\n   * // Use the above logicalTableId to get the underlying data reader on the active sheet\n   * const dataTableReader = await worksheet.getUnderlyingTableDataReaderAsync(logicalTableId);\n   * const page = await dataTableReader.getPageAsync(0);\n   * // ... process first page of data table ...\n   * await dataTableReader.releaseAsync();\n   * ```\n   */\n  getUnderlyingTableDataReaderAsync(\n    logicalTableId: string,\n    pageRowCount?: number,\n    options?: GetUnderlyingDataOptions,\n  ): Promise<DataTableReader>;\n\n  /**\n   * @hidden\n   * Selects the marks specified by mark ID using the MarkInfo interface.\n   * This is intended to be passed the MarkInfo objects that are received from a DataTable.\n   *\n   * @param marksInfo   The list of marks for the selection.\n   * @param updateType  The type of selection to make: add, remove, or replace.\n\n   * @returns           Empty promise that resolves when the selection is complete.\n   */\n  selectMarksByIDAsync(marksInfo: Array<MarkInfo>, updateType: SelectionUpdateType): Promise<void>;\n\n  /**\n   * Selects the marks specified by value using the SelectionCriteria interface.\n   * This is intended for manual construction of the desired selections.\n   *\n   * @param selectionCriteria   A list of criteria for which marks to select.\n   * @param updateType          The type of selection to make: add, remove, or replace.\n   *\n   * @returns                   Empty promise that resolves when the selection is complete.\n   * @since 1.10.0 Errors will now be thrown for invalid fields or values.\n   *\n   * </br>\n   *\n   * The following example shows how you might call this method using state names as the `SelectionCriteria`.\n   * The `SelectionUpdateType` is replace (`tableau.SelectionUpdateType.Replace`), so these values replace\n   * the marks that are currently selected.\n   * ```\n   *    worksheet.selectMarksByValueAsync([{\n   *         fieldName: 'State',\n   *         value: ['Texas', 'Washington', 'California']\n   *     }], tableau.SelectionUpdateType.Replace );\n   *\n   * ```\n   *\n   */\n  selectMarksByValueAsync(selectionCriteria: Array<SelectionCriteria>, updateType: SelectionUpdateType): Promise<void>;\n\n  /**\n   * Clears selected marks in the current worksheet.\n   *\n   * @return Empty promise that resolves when the selection has been cleared.\n   *\n   * The following example assumes that you have some marks already selected in the worksheet. After it has run,\n   * you should have no marks selected, and you should see the console message.\n   *\n   * ```\n   *    worksheet.clearSelectedMarksAsync().then(function () {\n   *        console.log('Your marks selection has been cleared!');\n   *    })\n   * ```\n   */\n  clearSelectedMarksAsync(): Promise<void>;\n\n  /**\n   * Add an annotation to the specified mark.\n   * This is intended to be passed a MarkInfo object received from a DataTable.\n   * MarkInfo can be found in the DataTable returned from getSelectedMarksAsync or getHighlightedMarksAsync.\n   *\n   * @param mark            The mark to annotate.\n   * @param annotationText  The text to display in the annotation.\n   *\n   * @returns Empty promise that resolves when the annotation is complete.\n   * @since   1.10.0 and Tableau 2022.4\n   *\n   * The following example shows how you might call this method using a MarkInfo object.\n   *\n   * ```\n   *    const markCollection = await worksheet.getSelectedMarksAsync();\n   *    const markToAnnotate = marksCollection.data[0].marksInfo[0];\n   *    await worksheet.annotateMarkAsync(markToAnnotate, 'Manufacturing line #2 shutdown triggered');\n   * ```\n   *\n   */\n  annotateMarkAsync(mark: MarkInfo, annotationText: string): Promise<void>;\n\n  /**\n   * Retrieves a list of the annotations in the worksheet.\n   *\n   * @returns           A list annotations in the worksheet.\n   * @since 1.10.0 and Tableau 2022.4\n   *\n   * The following example shows how you might call this method.\n   *\n   * ```\n   *    let annotations = await worksheet.getAnnotationsAsync();\n   *    console.log(annotations);\n   * ```\n   *\n   */\n  getAnnotationsAsync(): Promise<Array<Annotation>>;\n\n  /**\n   * Removes the corresponding annotation from the worksheet it belongs to.\n   * This is intended to be passed a Annotation object received from getAnnotationsAsync.\n   *\n   * @param annotation  The annotation to remove.\n   * @returns           Empty promise that resolves when the annotation is removed.\n   * @since 1.10.0 and Tableau 2022.4\n   *\n   * The following example shows how you might call this method using an annotation.\n   *\n   * ```\n   *    for (const annotation of annotations) {\n   *      await worksheet.removeAnnotationAsync(annotation);\n   *    }\n   * ```\n   *\n   */\n  removeAnnotationAsync(annotation: Annotation): Promise<void>;\n\n  /**\n   * Returns the visual specification for the worksheet, which can be used to get\n   * the mappings from fields to encodings backing the visual within the worksheet\n   *\n   * @returns Promise containing the VisualSpecification\n   * @since 1.11.0 and Tableau 2024.1\n   *\n   */\n  getVisualSpecificationAsync(): Promise<VisualSpecification>;\n\n  /**\n   * @hidden\n   * Add encoding fields to a marks card of the worksheet\n   *\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   * @since 1.13.0 and Tableau 2025.1\n   *\n   */\n  addMarksCardFieldsAsync(marksCardIndex: number, encodingType: EncodingType, columns: Array<Column>, startIndex: number): Promise<void>;\n\n  /**\n   * @hidden\n   * Move encoding field on a marks card of the worksheet\n   *\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   * @since 1.13.0 and Tableau 2025.1\n   *\n   */\n  moveMarksCardFieldAsync(marksCardIndex: number, fromIndex: number, toIndex: number): Promise<void>;\n\n  /**\n   * @hidden\n   * Add and delete encoding fields to a marks card of the worksheet\n   *\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   * @since 1.13.0 and Tableau 2025.1\n   *\n   */\n  spliceMarksCardFieldsAsync(\n    marksCardIndex: number,\n    encodingType: EncodingType,\n    startIndex: number,\n    deleteCount: number,\n    columns: Array<Column>,\n  ): Promise<void>;\n\n  /**\n   * Method to execute hover actions and render tooltip for a given tuple representing a mark in the visualization.\n   * If the tooltip parameter is included it will show the tooltip when the mark is hovered over.\n   * If null or no tooltip parameter is passed, no tooltip is shown.\n   * Hover actions are run by default, but passing false for the allowHoverActions parameter will prevent their execution.\n   *\n   * The `hoveredTuple` parameter is a tuple id. You can find the tuple id for a row of data by subtracting the index of the row from the total number of rows.\n   * For example, if you have 10 rows, and want to know the tuple id associated with the third row, it will be 7 (10 - 3 = 7). The last row of data will always have the tuple id of 1.\n   *\n   * Passing in an invalid tuple id will not throw and will clear the tooltip.\n   * <br/>\n   *\n   * ```\n   * svg.on('mousemove', (mouseEvent) => {\n   *  const myHoveredTuple = 10;\n   *  tableau.extensions.worksheetContent.worksheet.hoverTupleAsync(myHoveredTuple, { tooltipAnchorPoint: { x: mouseEvent.pageX, y: mouseEvent.pageY } })\n   *    .then(() => console.log('Done'))\n   *    .catch((error) => console.log('Failed to hover because of: ', error));\n   *  });\n   * ```\n   * @since 1.12.0 and Tableau 2024.2\n   * @category Viz Extensions\n   * @param hoveredTuple\n   * @param tooltip\n   * @param allowHoverActions\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   */\n  hoverTupleAsync(hoveredTuple: number, tooltip?: TooltipContext | null, allowHoverActions?: boolean): Promise<void>;\n\n  /**\n   * Method to modify selection, execute select actions, and render tooltip for a given list of tuples representing a mark or marks in the visualization.\n   * If the tooltip parameter is included it will show the tooltip when the mark or marks are selected. If not, no tooltip is shown.\n   *\n   * The `selectedTuples` parameter is an array of tuple ids. You can find the tuple id for a row of data by subtracting the index of the row from the total number of rows.\n   * For example, if you have 10 rows, and want to know the tuple id associated with the third row, it will be 7 (10 - 3 = 7). The last row of data will always have the tuple id of 1.\n   *\n   * Passing in an invalid tuple id will not throw and will clear the tooltip.\n   * <br/>\n   *\n   * ```\n   * svg.on('click', (mouseEvent) => {\n   * const myClickedTuples = [10];\n   * const ctrlKeyPressed = !!mouseEvent.ctrlKey;\n   * const selectOption = ctrlKeyPressed ? tableau.SelectOptions.Toggle : tableau.SelectOptions.Simple;\n   *\n   * tableau.extensions.worksheetContent.worksheet.selectTuplesAsync(myClickedTuples, selectOption, { tooltipAnchorPoint: { x: mouseEvent.pageX, y: mouseEvent.pageY } })\n   *    .then(() => console.log('Done'))\n   *    .catch((error) => console.log('Failed to select because of: ', error));\n   * });\n   * ```\n   * @since 1.12.0 and Tableau 2024.2\n   * @category Viz Extensions\n   * @param selectOption\n   * @param selectedTuples\n   * @param tooltip\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   */\n  selectTuplesAsync(selectedTuples: Array<number>, selectOption: SelectOptions, tooltip?: TooltipContext): Promise<void>;\n\n  /**\n   * Method to get the text of the tooltip that would be displayed for a given tuple id. Currently supported for web only.\n   *\n   * You can find the tuple id for a row of data by subtracting the index of the row from the total number of rows.\n   * For example, if you have 10 rows, and want to know the tuple id associated with the third row, it will be 7 (10 - 3 = 7). The last row of data will always have the tuple id of 1.\n   *\n   * Passing in an invalid tuple id will not throw.\n   * <br/>\n   *\n   * ```\n   * let navigatedTuple = -1;\n   * let updateScreenReaderElement = (screenReadertext) => {\n   *   // updates an element to be read out by screen readers\n   * };\n   *\n   * let updateNavigatedTuple = (keyboardEvent) => {\n   *   switch (keyboardEvent.key) {\n   *     case 'ArrowLeft':\n   *       navigatedTuple = navigatedTuple - 1;\n   *       break;\n   *     case 'ArrowRight':\n   *       navigatedTuple = navigatedTuple + 1;\n   *       break;\n   *     default:\n   *       break;\n   *   }\n   *   // do any work to show visual indication of a mark being navigated to\n   * };\n   *\n   * svg.on('keydown', (keyboardEvent) => {\n   *   updateNavigatedTuple(keyboardEvent);\n   *   tableau.extensions.worksheetContent.worksheet\n   *     .getTooltipTextAsync(navigatedTuple)\n   *     .then((response) => {\n   *       console.log(response.result);\n   *       updateScreenReaderElement(response.result);\n   *     })\n   *     .catch((error) => console.log('Failed to get tooltip text because of: ', error));\n   * });\n   * ```\n   * @since 1.12.0 and Tableau 2024.2\n   * @category Viz Extensions\n   * @param tupleId\n   * @returns Returns promise that resolves to a string describing the tooltip text for a given tuple id and rejects on error\n   */\n  getTooltipTextAsync(tupleId: number): Promise<String>;\n\n  /**\n   * Notifies the scene of a desire to leave mark-level keyboard navigation and return to scene-level keyboard navigation.\n   * Used when implementing [keyboard navigation](https://www.w3.org/TR/UNDERSTANDING-WCAG20/keyboard-operation.html) within a visualization, an integral part of building accessibility into a visualization.\n   * Currently supported for the web only.\n   * <br/>\n   *\n   * ```\n   * svg.on('keyup', (keyboardEvent) => {\n   *   if (keyboardEvent.key == \"Escape\") {\n   *     tableau.extensions.worksheetContent.worksheet\n   *       .leaveMarkNavigationAsync()\n   *       .then(() => console.log('Done'))\n   *       .catch((error) => console.log('Failed to leave mark-level keyboard navigation because of: ', error));\n   *   }\n   * });\n   * ```\n   * @since 1.12.0 and Tableau 2024.2\n   * @category Viz Extensions\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   */\n  leaveMarkNavigationAsync(): Promise<void>;\n\n  /**\n   * @hidden\n   * Opens the Edit Aliases dialog for a particular field\n   *\n   * @returns Returns empty promise that resolves when the extension host has successfully been informed of the request and rejects on error\n   * @since 1.13.0 and Tableau 2025.1\n   *\n   */\n  editAliasesDialogAsync(fieldName: string): Promise<void>;\n}\n\n/**\n * The `Dashboard` interface inherits from the `Sheet` interface.\n * @category Dashboard Extensions\n */\nexport interface Dashboard extends Sheet {\n  /**\n   * @returns  The collection of objects contained in the dashboard.\n   *\n   */\n  readonly objects: Array<DashboardObject>;\n\n  /**\n   *\n   *  This is a helper method and is equivalent to looping\n   *  through all of the objects in a dashboard and collecting all of the objects\n   *  whose type is `worksheet`. You can use this property to iterate\n   *  through all of the worksheets in the dashboard.\n   *\n   * @returns  The collection of worksheets contained in the dashboard.\n   *\n   * The following example uses the JavaScript `forEach()` method to traverse\n   * the worksheets in the dashboard.\n   * <br/>\n   *\n   * ```\n   *    let dashboard = tableau.extensions.dashboardContent.dashboard;\n   *    dashboard.worksheets.forEach(function (worksheet) {\n   *     // do something with the worksheets..\n   *       console.log(\"The worksheet name is \" + worksheet.name)\n   *     });\n   *\n   * ```\n   */\n  readonly worksheets: Array<Worksheet>;\n\n  /**\n   * @returns  The ID of the active object in the dashboard.\n   *\n   */\n  readonly activeDashboardObjectId: number;\n\n  /**\n   * @returns  The name of the active dashboard.\n   *\n   */\n  readonly activeDashboardName: string;\n\n  /**\n   * Sets the visibility of one or more floating dashboard zones.\n   * Throws an error if the zone is invalid\n   *\n   * @param zoneVisibilityMap    A map of zone ids to the desired state of visibility for that zone.\n   * @returns                    Empty promise that resolves when the visibility has been changed.\n   * @since 1.1.0\n   * @deprecated use setDashboardObjectVisibilityAsync\n   *\n   * The following example shows how you can update the visibility of multiple (valid, floating) zones in a dashboard\n   * <br/>\n   *\n   * ```\n   *   var zoneVisibilityMap = {};\n   *   zoneVisibilityMap[10] =  tableau.ZoneVisibilityType.Show;\n   *   zoneVisibilityMap[8] =  tableau.ZoneVisibilityType.Hide;\n   *   tableau.extensions.dashboardContent.dashboard.setZoneVisibilityAsync(zoneVisibilityMap).then(() => {\n   *     console.log(\"done\");\n   *   });\n   *\n   * ```\n   * @since 1.4.0 The zoneVisibilityMap can be either an untyped object, or a Map.\n   * ```\n   *   var zoneVisibilityMap = new Map;\n   *   zoneVisibilityMap.set(10, tableau.ZoneVisibilityType.Show);\n   *   zoneVisibilityMap.set(8, tableau.ZoneVisibilityType.Hide);\n   * ```\n   * @since 1.5.0 The zone can be any zone in the dashboard.\n   */\n  setZoneVisibilityAsync(zoneVisibilityMap: ZoneVisibilityMap): Promise<void>;\n\n  /**\n   * Sets the visibility of one or more dashboard objects.\n   * Throws an error if the dashboard object is invalid\n   *\n   * @param dashboardObjectVisibilityMap    A map of dashboard object ids to its desired state of visibility.\n   * @returns                               Empty promise that resolves when the visibility has been changed.\n   * @since 1.7.0 and Tableau 2021.4\n   *\n   * The following example shows how you can update the visibility of multiple valid dashboard objects\n   * <br/>\n   *\n   * ```\n   *   var dashboardObjectVisibilityMap = new Map();\n   *   dashboardObjectVisibilityMap.set(10, tableau.DashboardObjectVisibilityType.Show);\n   *   dashboardObjectVisibilityMap.set(8, tableau.DashboardObjectVisibilityType.Hide);\n   *   var dashboard = tableau.extensions.dashboardContent.dashboard;\n   *   dashboard.setDashboardObjectVisibilityAsync(dashboardObjectVisibilityMap).then(() => {\n   *     console.log(\"done\");\n   *   });\n   *\n   * ```\n   */\n  setDashboardObjectVisibilityAsync(dashboardObjectVisibilityMap: DashboardObjectVisibilityMap): Promise<void>;\n\n  /**\n   * Gets the specified dashboard object by its id. If a dashboard object is not found this method returns undefined.\n   *\n   * @param dashboardObjectId    The id of an object on the dashboard.\n   * @returns                    The dashboard object with that id. Returns undefined if the dashboard object is not found.\n   * @since 1.7.0 and Tableau 2021.4\n   *\n   * The following example shows how you can get a dashboard object using its id.\n   * <br/>\n   *\n   * ```\n   *   var dashboard = tableau.extensions.dashboardContent.dashboard;\n   *   var myDashboardObject = dashboard.getDashboardObjectById(8);\n   * ```\n   */\n  getDashboardObjectById(dashboardObjectId: number): DashboardObject | undefined;\n\n  /**\n   * Sets the position and size of one or more floating dashboard objects.\n   * Throws an error if the dashboard object is invalid\n   *\n   * @param DashboardObjectPositionAndSizeUpdateArray    Array of objects containing ID and\n   * new position and size for dashboard objects in a dashboard.\n   * @returns   Empty promise that resolves when the position and size of the dashboard objects have been changed.\n   * @since 1.7.0 and Tableau 2021.4\n   *\n   * The following example shows how you can update the position and size of multiple (valid, floating) dashboard objects in a dashboard\n   * <br/>\n   *\n   * ```\n   *   let dashboardObjectPositionAndSizeUpdateArray = [];\n   *   let dashboardObjectPositionAndSizeUpdate1 = {\n   *     dashboardObjectID: 1,\n   *     x: 0,\n   *     y: 0,\n   *     width: 50,\n   *     height: 50\n   *   };\n   *   let dashboardObjectPositionAndSizeUpdate2 = {\n   *     dashboardObjectID: 2,\n   *     x: 75,\n   *     y: 75,\n   *     width: 60,\n   *     height: 60\n   *   };\n   *   dashboardObjectPositionAndSizeUpdateArray.push(dashboardObjectPositionAndSizeUpdate1, dashboardObjectPositionAndsizeUpdate2);\n   *   tableau.extensions.dashboardContent.dashboard.moveAndResizeDashboardObjectsAsync(dashboardObjectPositionAndSizeUpdateArray)\n   *   .then(() => {\n   *     console.log(\"done\");\n   *   });\n   */\n  moveAndResizeDashboardObjectsAsync(dashboardObjectPositionAndSizeUpdateArray: DashboardObjectPositionAndSizeUpdateArray): Promise<void>;\n\n  /**\n   * Replays an animation for the active sheet\n   * Throws an error if the replay speed is invalid\n   *\n   * @param ReplaySpeedType    The replay speed type for the animation (slow, normal, fast).\n   * @returns              Empty promise that resolves when the animation has been replayed.\n   * @since 1.7.0 and Tableau 2021.4\n   *\n   * The following example shows how you can replay an animation in a dashboard.\n   * <br/>\n   *\n   * ```\n   *   let replaySpeed = tableau.ReplaySpeedType.Normal;\n   *   tableau.extensions.dashboardContent.dashboard.replayAnimationAsync(replaySpeed).then(() => {\n   *     console.log(\"done\");\n   *   });\n   */\n  replayAnimationAsync(replaySpeed: ReplaySpeedType): Promise<void>;\n\n  /**\n   * @returns The collection of filters used on the dashboard\n   * @since 1.9.0 and Tableau 2022.2\n   */\n  getFiltersAsync(): Promise<Array<Filter>>;\n\n  /**\n   * Applies a simple categorical filter (non-date) to the dashboard.\n   * This method is similar to the method used for worksheets, but applies the filter to all the worksheets in the dashboard that have that same field.\n   * Note that the filter is ignored by a worksheet if the worksheet doesn't have the relevant field in its data source.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   * @since 1.9.0 and Tableau 2022.2\n   */\n  applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;\n}\n\n/**\n * Map object that can be passed into setZoneVisibilityAsync.\n * @deprecated\n * @category Dashboard Extensions\n */\nexport declare type ZoneVisibilityMap = Map<number, ZoneVisibilityType> | object;\n\n/**\n * Map object that can be passed into setDashboardObjectVisibilityAsync.\n * @category Dashboard Extensions\n */\nexport declare type DashboardObjectVisibilityMap = Map<number, DashboardObjectVisibilityType>;\n\n/**\n * Array object that can be passed into moveAndResizeDashboardObjects.\n * @category Dashboard Extensions\n */\nexport declare type DashboardObjectPositionAndSizeUpdateArray = Array<DashboardObjectPositionAndSizeUpdate>;\n\n/**\n * An object to specify a dashboard object and its new position and size in a dashboard.\n * @category Dashboard Extensions\n */\nexport interface DashboardObjectPositionAndSizeUpdate {\n  /**\n   * @returns  dashboard object ID\n   */\n  readonly dashboardObjectID: number;\n\n  /**\n   * @returns  X coordinate\n   */\n  readonly x: number;\n\n  /**\n   * @returns  Y coordinate\n   */\n  readonly y: number;\n\n  /**\n   * @returns  width\n   */\n  readonly width: number;\n\n  /**\n   * @returns  height\n   */\n  readonly height: number;\n}\n\n/**\n * An object of a dashboard.\n * @category Dashboard Extensions\n */\nexport interface DashboardObject {\n  /**\n   * @returns The Dashboard object that contains this object.\n   */\n  readonly dashboard: Dashboard;\n\n  /**\n   * @returns  What the object represents.\n   */\n  readonly type: DashboardObjectType;\n\n  /**\n   * @returns  The coordinates relative to the top-left corner of the dashboard containing this object.\n   */\n  readonly position: Point;\n\n  /**\n   * @returns  The size of the object.\n   */\n  readonly size: Size;\n\n  /**\n   * @returns  If type returns WORKSHEET or QUICKFILTER, this returns a Worksheet object, undefined otherwise.\n   */\n  readonly worksheet: Worksheet | undefined;\n\n  /**\n   * @returns The name of the dashboard object. This is the name given to the object during authoring.\n   * @since 1.1.0\n   */\n  readonly name: string;\n\n  /**\n   * @returns True if the object is floating in the dashboard.\n   * @since 1.1.0\n   */\n  readonly isFloating: boolean;\n\n  /**\n   * @returns True if the object is visible.\n   * @since 1.1.0\n   */\n  readonly isVisible: boolean;\n\n  /**\n   * @returns  The id of the dashboard object\n   * @since 1.1.0\n   */\n  readonly id: number;\n\n  /**\n   * @returns  The field id of the dashboard object if it is a QuickFilter\n   */\n  readonly fieldId: string | undefined;\n}\n\n/**\n * Represents an x/y coordinate in pixels.\n */\nexport interface Point {\n  /**\n   * @returns  X coordinate of point.\n   */\n  readonly x: number;\n\n  /**\n   * @returns  Y coordinate of point.\n   */\n  readonly y: number;\n}\n\n/**\n * Levels to apply to a hierarchical filter\n * @since Extensions 1.10.0 and Tableau version 2022.3\n */\nexport interface HierarchicalLevels {\n  levels: Array<string>;\n}\n"]}