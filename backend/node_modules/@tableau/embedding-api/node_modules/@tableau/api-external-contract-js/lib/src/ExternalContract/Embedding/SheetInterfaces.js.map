{"version":3,"file":"SheetInterfaces.js","sourceRoot":"","sources":["../../../../src/ExternalContract/Embedding/SheetInterfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { Annotation } from '../Shared/AnnotationInterfaces';\nimport { DataSource, LogicalTable } from '../Shared/DataSourceInterfaces';\nimport { Column, DataTable, DataTableReader, GetSummaryDataOptions, GetUnderlyingDataOptions } from '../Shared/DataTableInterfaces';\nimport { Filter, FilterOptions, RangeFilterOptions, RelativeDateFilterOptions } from '../Shared/FilterInterfaces';\nimport { DashboardObjectType, FilterUpdateType, SelectionUpdateType, SheetType } from '../Shared/Namespaces/Tableau';\nimport { MarkInfo, MarksCollection, SelectionCriteria } from '../Shared/SelectionInterfaces';\nimport { Size } from '../Shared/SheetInterfaces';\nimport { VisualSpecification } from '../Shared/VisualModelInterface';\nimport { ApiMenuType, SheetSizeBehavior } from './Enums';\nimport { StoryPoint } from './StoryInterfaces';\nimport { Workbook } from './WorkbookInterface';\n\nexport interface SheetSize {\n  /**\n   * The sizing method for a sheet. The value must be one of the following: Automatic, Exactly, Range, AtLeast, and AtMost.\n   * Exactly, Range, AtLeast, and AtMost are used in combination with minSize or maxsize.\n   */\n  readonly behavior: SheetSizeBehavior;\n\n  /**\n   *  The minimum size of the sheet. This is only defined when behavior is Exactly, Range, or AtLeast.\n   */\n  readonly minSize?: Size;\n\n  /**\n   *  The maximum size of the sheet. This is only defined when behavior is Exactly, Range or AtMost.\n   */\n  readonly maxSize?: Size;\n}\n\nexport interface Sheet {\n  /**\n   * @returns The name of the sheet.\n   */\n  readonly name: string;\n\n  /**\n   * @returns The type of the sheet.\n   */\n  readonly sheetType: SheetType;\n\n  /**\n   * @returns A value indicating whether the sheet is the currently active sheet.\n   */\n  readonly isActive: boolean;\n\n  /**\n   * @returns  A value indicating whether the sheet is hidden (true) or visible (false) in the UI.\n   * Note that if the entire tab control is hidden, it does not affect the state of this flag.\n   * This sheet may still report that it is visible even when the tabs control is hidden.\n   */\n  readonly isHidden: boolean;\n\n  /**\n   * @returns The index of the sheet within the published tabs. Note that hidden tabs are still\n   * counted in the ordering, as long as they are published.\n   */\n  readonly index: number;\n\n  /**\n   * @returns the URL for this sheet.\n   */\n  readonly url: string;\n\n  /**\n   * @returns The size information that the author specified when publishing the workbook.\n   */\n  readonly size: SheetSize;\n\n  /**\n   * @returns The workbook containing this sheet\n   */\n  readonly workbook: Workbook;\n\n  /**\n   * Sets the size information of a sheet. Note that if the sheet is a Worksheet, only SheetSizeBehavior.Automatic\n   * is allowed since you can't actually set a Worksheet to a fixed size.\n   */\n  changeSizeAsync(sheetSize: SheetSize): Promise<SheetSize>;\n}\n\n/**\n * Information needed to insert and display an external context menu item.\n */\nexport interface ContextMenuOptions {\n  readonly displayName: string;\n}\n\n/**\n * A query state for use with Tableau Pulse.\n * @ignore\n */\nexport interface EmbeddingAbstractQuery {\n  abstractQuery: string;\n}\n\n/**\n * The viz state and data model.\n * @ignore\n */\nexport interface EmbeddingVizStateWithDataModel {\n  vizStateWithDataModel: string;\n}\n\n/**\n * A worksheet for use with Tableau Pulse.\n * @ignore\n */\nexport interface AuthoringWorksheet {\n  /**\n   * Gets the abstract query and data model from the VizClient.\n   *\n   * @returns {Promise<EmbeddingAbstractQuery>} - the currently active sheet (the active tab).\n   * @deprecated\n   * @ignore\n   */\n  getAbstractQueryWithDataModelAsync(): Promise<EmbeddingAbstractQuery>;\n\n  /**\n   * Gets the viz state and data model from the VizClient.\n   *\n   * @returns {Promise<EmbeddingVizStateWithDataModel>} - the viz state and data model for the currently active sheet (the active tab).\n   * @ignore\n   */\n  getVizStateWithDataModelAsync(): Promise<EmbeddingVizStateWithDataModel>;\n\n  /**\n   * Sets the viz state and data model in the VizClient.\n   * @param {EmbeddingVizStateWithDataModel} vizStateWithDataModel - The viz state with data model.\n   * @returns {Promise<void>} Promise which resolves to void.\n   * @ignore\n   */\n  setVizStateWithDataModelAsync(vizStateWithDataModel: EmbeddingVizStateWithDataModel): Promise<void>;\n}\n\nexport interface Worksheet extends Sheet {\n  /**\n   * @returns  The dashboard object to which this worksheet belong. If the worksheet is not on a dashboard, it returns null.\n   */\n  readonly parentDashboard: Dashboard | null;\n\n  /**\n   * @returns  The {@link StoryPoint} object to which this worksheet belongs. If the worksheet is not in a story, it returns null.\n   */\n  readonly parentStoryPoint: StoryPoint | null;\n\n  /**\n   * Gets the data sources for this worksheet. Note that calling this method might negatively impact performance\n   *  and responsiveness of the viz that you are embedding. The method is partly\n   *  asynchronous but includes some serial operations.\n   *\n   * @returns The primary data source and all of the secondary data sources for this worksheet.\n   *          By convention the first data source in the array is the primary.\n   *\n   * The following example shows how you might find a specific data source of a worksheet,\n   * using the `getDataSourcesAsync()` method. You could then call the `getLogicalTablesAsync()` method\n   * to get the logical tables in the data source, and then use the either the `DataSource` or the\n   * `Worksheet` to get the underlying table data.\n   *\n   * Use `await` only inside an Async function\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    let dataSources = await vizActiveSheet.getDataSourcesAsync();\n   *    console.log(dataSources[0].name);\n   *    let dataSource = dataSources.find(datasource => datasource.name === \"Sample - Superstore\");\n   *    // process the dataSource\n   * }\n   * ```\n   *\n   */\n  getDataSourcesAsync(): Promise<Array<DataSource>>;\n\n  /**\n   * Gets the summary data table for a worksheet.\n   * Warning: getSummaryDataAsync can fail with a worksheet with many rows of data and is now deprecated.\n   *\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the summary data for the worksheet.\n   *\n   * @deprecated Use getSummaryDataReaderAsync to avoid failures with many rows of data.\n   *\n   * Example shows how to replace unsafe usage of `getSummaryDataAsync` with\n   * `getSummaryDataReaderAsync` and `getAllPagesAsync` assuming less than 4,000,000\n   * rows of data.\n   *\n   *```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *   const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();\n   *   const dataTable = await dataTableReader.getAllPagesAsync();\n   *   await dataTableReader.releaseAsync();\n   *   // ... process data table ...\n   * }\n   *```\n   *\n   * Example shows how to replace unsafe usage of `getSummaryDataAsync` with\n   * `getSummaryDataReaderAsync` and `getPageAsync` and work with individual\n   * pages.\n   *```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *   const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();\n   *   for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {\n   *     const dataTablePage = await dataTableReader.getPageAsync(currentPage);\n   *     // ... process current page ....\n   *   }\n   *   await dataTableReader.releaseAsync();\n   * }\n   *```\n   */\n  getSummaryDataAsync(options?: GetSummaryDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets a summary data table reader for this worksheet.\n   * Only one active DataTableReader for summary data is supported.\n   *\n   * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.\n   * @param options  Collection of options to change the behavior of the reader.\n   * @returns        A data table reader to access the summary data for the worksheet.\n   *\n   *  Example showing the methods to get and use the summary data reader for all rows in a worksheet.\n   *  Use `await` only inside an Async function\n   *```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *     const dataTableReader = await vizActiveSheet.getSummaryDataReaderAsync();\n   *     for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {\n   *         const dataTablePage = await dataTableReader.getPageAsync(currentPage);\n   *         // ... process current page ....\n   *     }\n   *     await dataTableReader.releaseAsync();\n   * }\n   *```\n   */\n  getSummaryDataReaderAsync(pageRowCount?: number, options?: GetSummaryDataOptions): Promise<DataTableReader>;\n\n  /**\n   * Gets the columns that are returned with `getSummaryDataAsync` or `getSummaryDataReaderAsync`.\n   * The columns are sorted in the order that they appear in the view or in the View Data window.\n   * Note that `getSummaryDataReaderAsync` returns the summary data sorted with the columns\n   * in alphabetical (ascending) order. You can use  method to determine the view order..\n   *\n   * @returns The array of columns that describe the data in the worksheet.\n   */\n  getSummaryColumnsInfoAsync(): Promise<Array<Column>>;\n\n  /**\n   * Gets the underlying data table for this worksheet.\n   *\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the underlying data for the worksheet.\n   *\n   *\n   * You can use the `GetUnderlyingDataOptions.maxRows` property to request the number of rows of data to return.\n   * If unspecified (maxRows == '0'), the call to `getUnderlyingDataAsync` requests all rows in the data source.\n   * Note that the maximum number of rows returned from the `getUnderlyingDataAsync()` method is limited\n   * to 10,000 rows. You can use the `DataTable` property, `isTotalRowCountLimited`, to test whether there is\n   * more data. A value of true indicates that the calling function requested more rows than the limit (10,000) and the\n   * underlying data source contains more rows than can be returned.\n   *\n   * In the following example, the `getUnderlyingDataAsync()` method is used to get the underlying data for\n   * a specific column in a workbook.\n   * Use `await` only inside an Async function\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    let dataTable = await  vizActiveSheet.getUnderlyingDataAsync();\n   *    let field = dataTable.columns.find(column => column.fieldName === \"Sales\");\n   *    let list = [];\n   *    for (let row of dataTable.data) {\n   *         list.push(row[field.index].value);\n   *    }\n   *    let values = list.filter((el, i, arr) => arr.indexOf(el) === i);\n   *    console.log(values);\n   * }\n   *\n   * ```\n   * @deprecated Use Worksheet.getUnderlyingTableDataReaderAsync or Worksheet.getUnderlyingTableDataAsync.\n   *\n   */\n  getUnderlyingDataAsync(options?: GetUnderlyingDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets the underlying logical tables used by the worksheet. The resulting logical tables are determined by the measures in the worksheet.\n   * If a worksheet's data source contains multiple logical tables and the worksheet contains only measures from one logical table, this API\n   * will return one logical table.\n   *\n   * @returns An array of logical tables corresponding to the measures referenced by the worksheet.\n   * Use `await` only inside an Async function\n   *\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    // Call to get the underlying logical tables used by the worksheet\n   *    let underlyingTablesData = await vizActiveSheet.getUnderlyingTablesAsync();\n   *    let logicalTableId = underlyingTablesData[0].id;\n   *    // Use the above logicalTableId to get the underlying data on the active sheet\n   *    // by calling worksheet.getUnderlyingTableDataAsync(logicalTableId)\n   *    let underlyingTableDataForId = await vizActiveSheet.getUnderlyingTableDataAsync(logicalTableId);\n   * }\n   * ```\n   */\n  getUnderlyingTablesAsync(): Promise<Array<LogicalTable>>;\n\n  /**\n   * Gets the underlying data table for the given logical table id.\n   * Use the `getUnderlyingTablesAsync` method to identify the logical tables.\n   *\n   * @param logicalTableId logical table id.\n   * @param options  Collection of options to change the behavior of the call.\n   * @returns        A data table containing the underlying data for the given logical table id\n   *\n   * You can use the `getUnderlyingDataOptions.maxRows` property to request the number of rows of data to return.\n   * If unspecified (maxRows == '0'), the call to `getUnderlyingTableDataAsync` requests all rows in the logical table.\n   * Note that the maximum number of rows returned from the `getUnderlyingTableDataAsync()` method is limited\n   * to 10,000 rows. You can use the `DataTable` property, `isTotalRowCountLimited`, to test whether there is\n   * more data. A value of true indicates that the calling function requested more rows than the limit (10,000) and the\n   * underlying data source contains more rows than can be returned.\n   *\n   * @see getUnderlyingTableDataReaderAsync to read more than 10,000 rows.\n   * ```\n   * var worksheet = tableau.extensions.dashboardContent.dashboard.worksheets.find(w => w.name === \"Sale Map\");\n   * const logicalTables = await worksheet.getUnderlyingTablesAsync();\n   * const dataTable = await worksheet.getUnderlyingTableDataAsync(logicalTables[0].id)\n   * // process the dataTable...\n   * ```\n   */\n  getUnderlyingTableDataAsync(logicalTableId: string, options?: GetUnderlyingDataOptions): Promise<DataTable>;\n\n  /**\n   * Gets a underlying data table reader for the given logical table id.\n   * Use the `getUnderlyingTablesAsync` method to identify the logical tables.\n   * Only one active DataTableReader per logical table id is supported.\n   *\n   * `getUnderlyingTableDataReaderAsync` attempts to prepare all the rows of the underlying table to be read as pages.\n   * However, there is a limit to the number of rows that can be prepared. The default limit is 1 million rows of data.\n   * You can change the default limit with the Tableau Server (Cloud) or Tableau Desktop option: ExtensionsAndEmbeddingReaderRowLimit.\n   * If the underlying table has many columns, `getUnderlyingTableDataReaderAsync` can be sped up by only requesting\n   * native data values in the GetUnderlyingDataOptions.\n   *\n   * @param logicalTableId logical table id.\n   * @param pageRowCount The number of rows per page. The default and maximum is 10,000 rows.\n   * @param options  Collection of options to change the behavior of the reader.\n   * @returns        A data table reader to access the underlying data for the given logical table id.\n   *\n   * The following example shows getting the first page of underlying data.\n   * Use `await` only inside an Async function\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    // Call to get the underlying logical tables used by the worksheet\n   *    const underlyingTablesData = await vizActiveSheet.getUnderlyingTablesAsync();\n   *    const logicalTableId = underlyingTablesData[0].id;\n   *    // Use the above logicalTableId to get the underlying data reader on the active sheet\n   *    const dataTableReader = await vizActiveSheet.getUnderlyingTableDataReaderAsync(logicalTableId);\n   *    const page = await dataTableReader.getPageAsync(0);\n   *    // ... process first page ....\n   *    await dataTableReader.releaseAsync();\n   * }\n   * ```\n   */\n  getUnderlyingTableDataReaderAsync(\n    logicalTableId: string,\n    pageRowCount?: number,\n    options?: GetUnderlyingDataOptions,\n  ): Promise<DataTableReader>;\n\n  /**\n   * Gets the list of filters on a worksheet. Hierarchical filters are not yet supported\n   * @returns A promise that resolves to the collection of filters used in this worksheet.\n   */\n  getFiltersAsync(): Promise<Array<Filter>>;\n\n  /**\n   * Applies the list of provided categorical filter values.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   */\n  applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;\n\n  /**\n   * Applies a range filter to a quantitative or date field.\n   *\n   * @param fieldName      The name of the field to filter on\n   * @param filterOptions  Filter Options: min, max, nullOption. Atleast one of of min and max is required.\n   * For applying date filters, UTC Date objects are expected. (i.e., var min = new Date(Date.UTC(1999, 0, 1)))\n   * @return The field name that the filter is applied on.\n   */\n  applyRangeFilterAsync(fieldName: string, filterOptions: RangeFilterOptions): Promise<string>;\n\n  /**\n   * Resets existing filters on the given field.\n   * Categorical filters are reset to \"All,\" and range filters are reset to the full range.\n   * Relative date filters can not be reset, consider using the applyRelativeDateFilterAsync API.\n   *\n   * @param fieldName  The name of the field to clear filter on.\n   *\n   * @returns The field to clear filter on.\n   */\n  clearFilterAsync(fieldName: string): Promise<string>;\n\n  /**\n   * Applies a relative date filter.\n   *\n   * @param fieldName The name of the field to filter on.\n   * @param options   The relative date filter options (anchorDate, periodType, rangeType, rangeN). When the rangeType is LASTN or NEXTN, the rangeN is required.\n   *\n   * @returns  The field name that the filter is applied on.\n   *\n   * The following example shows how to apply a relative date filter from a worksheet.\n   * ```\n   *  worksheet.applyRelativeDateFilterAsync(\n   *    'Order Date',\n   *    {\n   *      anchorDate: new Date(Date.UTC(2022, 4, 13)),\n   *      periodType: PeriodType.Years,\n   *      rangeType: DateRangeType.LastN,\n   *      rangeN: 1,\n   *    }\n   *  );\n   * ```\n   */\n  applyRelativeDateFilterAsync(fieldName: string, options: RelativeDateFilterOptions): Promise<string>;\n\n  /**\n   * Applies the list of provided hierarchial filter values.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values or levels to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   *\n   */\n  applyHierarchicalFilterAsync(\n    fieldName: string,\n    values: Array<string> | HierarchicalLevels,\n    updateType: FilterUpdateType,\n    options: FilterOptions,\n  ): Promise<string>;\n\n  /**\n   * Clears selected marks in the current worksheet.\n   *\n   * @return Empty promise that resolves when the selection has been cleared.\n   *\n   * The following example assumes that you have some marks already selected in the worksheet. After it has run,\n   * you should have no marks selected, and you should see the console message.\n   * Use `await` only inside an Async function\n   *\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    // clear selected marks\n   *    await vizActiveSheet.clearSelectedMarksAsync();\n   *    console.log('Your marks selection has been cleared!');\n   * }\n   * ```\n   */\n  clearSelectedMarksAsync(): Promise<void>;\n\n  /**\n   * Gets the data for the marks which are currently selected on the worksheet.\n   * If there are no marks currently selected, an empty model is returned.\n   *\n   * @returns The marks that are selected.\n   *\n   * Use `await` only inside an Async function\n   *\n   * ```\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"worksheet\") {\n   *    // Call to get the selected marks for the worksheet\n   *    let selectedMarks = await vizActiveSheet.getSelectedMarksAsync();\n   *    // Get the first DataTable for our selected marks (usually there is just one)\n   *    const dataTableName = selectedMarks.data[0];\n   *    // Map the data into a format for display, etc.\n   * }\n   * ```\n   *\n   *\n   */\n  getSelectedMarksAsync(): Promise<MarksCollection>;\n\n  /**\n   * Selects the marks by value, using the SelectionCriteria interface.\n   * This is intended for manual construction of the desired selections.\n   *\n   * @param selections   A list of criteria for which marks to select.\n   * @param updateType          The type of selection to make: add, remove, or replace.\n   *\n   * @returns                   Empty promise that resolves when the selection is complete.\n   *\n   * The following example shows how you might call this method using state names as the `SelectionCriteria`.\n   * The `SelectionUpdateType` is replace (`SelectionUpdateType.Replace`), so these values replace\n   * the marks that are currently selected.\n   *\n   * ```\n   *    worksheet.selectMarksByValueAsync([{\n   *         fieldName: 'State',\n   *         value: ['Texas', 'Washington', 'California']\n   *     }], SelectionUpdateType.Replace );\n   *\n   * ```\n   *\n   */\n  selectMarksByValueAsync(selections: Array<SelectionCriteria>, updateType: SelectionUpdateType): Promise<void>;\n\n  /**\n   * Add an annotation to the specified mark.\n   * This is intended to be passed a MarkInfo object received from a DataTable.\n   * MarkInfo can be found in the DataTable returned from getSelectedMarksAsync.\n   *\n   * @param mark            The mark to annotate.\n   * @param annotationText  The text to display in the annotation.\n   *\n   * @returns Empty promise that resolves when the annotation is complete.\n   *\n   * The following example shows how you might call this method using a MarkInfo object.\n   *\n   * ```\n   *    const markCollection = await worksheet.getSelectedMarksAsync();\n   *    const markToAnnotate = marksCollection.data[0].marksInfo[0];\n   *    await worksheet.annotateMarkAsync(markToAnnotate, 'Manufacturing line #2 shutdown triggered');\n   * ```\n   *\n   */\n  annotateMarkAsync(mark: MarkInfo, annotationText: string): Promise<void>;\n\n  /**\n   * Retrieves a list of the annotations in the worksheet.\n   *\n   * @returns           A list annotations in the worksheet.\n   *\n   * The following example shows how you might call this method.\n   *\n   * ```\n   *    let annotations = await worksheet.getAnnotationsAsync();\n   *    console.log(annotations);\n   * ```\n   *\n   */\n  getAnnotationsAsync(): Promise<Array<Annotation>>;\n\n  /**\n   * Removes the corresponding annotation from the worksheet it belongs to.\n   * This is intended to be passed an Annotation object received from getAnnotationsAsync.\n   *\n   * @param annotation  The annotation to remove.\n   * @returns           Empty promise that resolves when the annotation is removed.\n   *\n   * The following example shows how you might call this method using an annotation object.\n   *\n   * ```\n   *    for (const annotation of annotations) {\n   *      await worksheet.removeAnnotationAsync(annotation);\n   *    }\n   * ```\n   *\n   */\n  removeAnnotationAsync(annotation: Annotation): Promise<void>;\n\n  /**\n   * Adds external context menu item into location defined by targetMenu input parameter.\n   *\n   * Calling this function does not have immediate affect, it just registers new menu item.\n   * When the corresponding context menu is later shown, the new menu item is also rendered there.\n   *\n   * The return value of this function is the unique identifier for the newly inserted context menu item.\n   *\n   * When the user clicks the new context menu item, a TableauEvent is raised.\n   * Each targetMenu parameter will have a different event type.\n   * The unique identifier could be used to distinguish different menu items that have the same event type.\n   *\n   * @param targetMenu Defines where to insert the new external menu item.\n   * @param config Provides configuration information for new external menu item.\n   * @returns Unique identifier for newly inserted context menu item.\n   */\n  appendContextMenuAsync(targetMenu: ApiMenuType, config: ContextMenuOptions): Promise<string>;\n\n  /**\n   * Removes the external context menu item inserted by the appendContextMenuAsync method.\n   *\n   * The parameter menuItemId specifies the menu item to remove and is the return\n   * value from the appendContextMenuAsync method.\n   *\n   * Once this function is called, menu item identified by menuItemId won't be rendered to the user\n   * in corresponding context menu.\n   *\n   * @param targetMenu Defines where to remove new external menu item.\n   * @param menuItemId Unique identifier of external context menu item that user wants to remove.\n   */\n  removeContextMenuAsync(targetMenu: ApiMenuType, menuItemId: string): Promise<void>;\n\n  /**\n   * Executes the external context menu item inserted by the appendContextMenuAsync method.\n   *\n   * The parameter menuItemId specifies the menu item to execute and is the return\n   * value from the appendContextMenuAsync method.\n   *\n   * Once this function is called, menu item identified by menuItemId will be executed.\n   *\n   * @param targetMenu Defines where to execute new external menu item.\n   * @param menuItemId Unique identifier of external context menu item that user wants to execute.\n   */\n  executeContextMenuAsync(targetMenu: ApiMenuType, menuItemId: string): Promise<void>;\n\n  /**\n   * Sets the displayed header for the external context menu.\n   *\n   * The parameter menuHeader specifies the header to be displayed.\n   *\n   * Once this function is called, menuHeader will be rendered to the user as the header\n   * for corresponding context menu. If not called, a default header will be displayed.\n   *\n   * @param targetMenu Specifies the location of the external context menu.\n   * @param menuHeader Defines a header string to be displayed for the menu.\n   * @param menuDescription Defines a description of the menu to be displayed in a tooltip\n   */\n  renameContextMenuAsync(targetMenu: ApiMenuType, menuHeader: string, menuDescription: string): Promise<void>;\n\n  /**\n   * Returns the visual specification for the worksheet, which can be used to get\n   * the mappings from fields to encodings backing the visual within the worksheet\n   *\n   * @returns Promise containing the VisualSpecification\n   */\n  getVisualSpecificationAsync(): Promise<VisualSpecification>;\n}\n\nexport interface Dashboard extends Sheet {\n  /**\n   * @returns  The collection of objects contained in the dashboard.\n   *\n   */\n  readonly objects: Array<DashboardObject>;\n\n  /**\n   *\n   *  This is a helper method and is equivalent to looping\n   *  through all of the objects in a dashboard and collecting all of the objects\n   *  whose type is `worksheet`. You can use this property to iterate\n   *  through all of the worksheets in the dashboard.\n   *\n   * @returns  The collection of worksheets contained in the dashboard.\n   *\n   * The following example uses the JavaScript `forEach()` method to traverse\n   * the worksheets in the dashboard.\n   * <br/>\n   *\n   *\n   * ```\n   *\n   * let vizActiveSheet = viz.workbook.activeSheet;\n   * if (vizActiveSheet.sheetType === \"dashboard\") {\n   *    vizActiveSheet.worksheets.forEach(function (worksheet) {\n   *    // do something with the worksheets..\n   *    })\n   * }\n   *\n   * ```\n   */\n  readonly worksheets: Array<Worksheet>;\n\n  /**\n   * @returns  Returns the {@link StoryPoint} object to which this Dashboard belongs. If the Dashboard doesn't belong to a story, it returns null.\n   */\n  readonly parentStoryPoint: StoryPoint | null;\n\n  /**\n   * @returns The collection of filters used on the dashboard\n   */\n  getFiltersAsync(): Promise<Array<Filter>>;\n\n  /**\n   * Applies a simple categorical filter (non-date) to the dashboard.\n   * This method is similar to the method used for worksheets, but applies the filter to all the worksheets in the dashboard that have that same field.\n   * Note that the filter is ignored by a worksheet if the worksheet doesn't have the relevant field in its data source.\n   *\n   * @param fieldName      The name of the field to filter on.\n   * @param values         The list of values to filter on.\n   * @param updateType     The update type of this filter (add, all, remove, replace).\n   * @param filterOptions  Advanced filter options (isExcludeMode).\n   *\n   * @returns  The field name that the filter is applied on.\n   */\n  applyFilterAsync(fieldName: string, values: Array<string>, updateType: FilterUpdateType, filterOptions: FilterOptions): Promise<string>;\n}\n\n/**\n * An object of a dashboard.\n */\nexport interface DashboardObject {\n  /**\n   * @returns The Dashboard object that contains this object.\n   */\n  readonly dashboard: Dashboard;\n\n  /**\n   * @returns  What the object represents.\n   */\n  readonly type: DashboardObjectType;\n\n  /**\n   * @returns  The coordinates relative to the top-left corner of the dashboard containing this object.\n   */\n  readonly position: Point;\n\n  /**\n   * @returns  The size of the object.\n   */\n  readonly size: Size;\n\n  /**\n   * @returns  If type returns WORKSHEET, this returns a Worksheet object, undefined otherwise.\n   */\n  readonly worksheet: Worksheet | undefined;\n\n  /**\n   * @returns The name of the dashboard object. This is the name given to the object during authoring.\n   */\n  readonly name: string;\n\n  /**\n   * @returns True if the object is floating in the dashboard.\n   */\n  readonly isFloating: boolean;\n\n  /**\n   * @returns True if the object is visible.\n   */\n  readonly isVisible: boolean;\n\n  /**\n   * @returns  The id of the dashboard object\n   */\n  readonly id: number;\n}\n\n/**\n * Represents an x/y coordinate in pixels.\n */\nexport interface Point {\n  /**\n   * @returns  X coordinate of point.\n   */\n  readonly x: number;\n\n  /**\n   * @returns  Y coordinate of point.\n   */\n  readonly y: number;\n}\n\nexport interface SheetInfo {\n  /**\n   * @returns the name of the sheet.\n   */\n  readonly name: string;\n\n  /**\n   * @returns the index of the sheet within the published tabs. Note that hidden tabs are still counted in the ordering,\n   * as long as they are published.\n   */\n  readonly index: number;\n\n  /**\n   * @returns a value indicating whether the sheet is the currently active sheet.\n   * Due to a technical limitation, this will always return false if the object is a Worksheet instance that is part of a Dashboard.\n   */\n  readonly isActive: boolean;\n\n  /**\n   * @returns a value indicating whether the sheet is hidden in the UI.\n   * Note that if the entire tab control is hidden, it does not affect the state of this flag.\n   * This sheet may still report that it is visible even when the tabs control is hidden.\n   */\n  readonly isHidden: boolean;\n\n  /**\n   * @returns The type of the sheet. SheetType is an enum with the following values: WORKSHEET, DASHBOARD and STORY.\n   */\n  readonly sheetType: SheetType;\n\n  /**\n   * @returns The Workbook to which this Sheet belongs.\n   */\n  readonly workbook: Workbook;\n\n  /**\n   * @returns The URL for this sheet.\n   */\n  readonly url: string;\n\n  /**\n   * @returns The size information that the author specified when publishing the workbook.\n   */\n  readonly size: SheetSize;\n}\n\n/**\n * Levels to apply to a hierarchical filter\n */\nexport interface HierarchicalLevels {\n  levels: Array<string>;\n}\n"]}