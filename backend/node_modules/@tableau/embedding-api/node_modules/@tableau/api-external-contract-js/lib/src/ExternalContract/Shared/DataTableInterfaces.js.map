{"version":3,"file":"DataTableInterfaces.js","sourceRoot":"","sources":["../../../../src/ExternalContract/Shared/DataTableInterfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { DataType, IncludeDataValuesOption } from './Namespaces/Tableau';\nimport { MarkInfo } from './SelectionInterfaces';\n\nexport interface Column {\n  /**\n   * @returns  The name of the field in the column. In summary data, this includes the aggregation.\n   * The summary data field name is not stable across languages.\n   * For example, in an English version of Tableau, the field name might be SUM(Sales). In French, this would be SOMME(Sales).\n   */\n  readonly fieldName: string;\n\n  /**\n   * @returns  The fieldId of the field in the column. In summary data, this includes the aggregation.\n   * The fieldId is not stable across replacing data sources.\n   * For example after replacing the data source [Clipboard_20210305T164000].[sum:Sales:qk] could become\n   * [federated.12usuoq1171o1b1ebdyh60fjnev1].[sum:Sales:qk].\n   *\n   * @since 1.5.0\n   */\n  readonly fieldId: string;\n\n  /**\n   * @returns The data type of the column. Possible values are\n   *           float, integer, string, boolean, date, datetime and spatial\n   */\n  readonly dataType: DataType;\n\n  /**\n   * @returns  Whether the column data is referenced in the visualization.\n   */\n  readonly isReferenced: boolean;\n\n  /**\n   * @returns  The number of rows in the returned data.\n   */\n  readonly index: number;\n}\n\nexport interface DataTable {\n  /**\n   * @returns  Either \"Underlying Data Table\" or \"Summary Data Table\".\n   */\n  readonly name: string;\n\n  /**\n   * @returns  A two-dimensional array of data without the sheet or column\n   *           metadata. The first array index is the row index and the second\n   *           array index is the column index.\n   */\n  readonly data: Array<Array<DataValue>>;\n\n  /**\n   * @returns  An array of information about marks.  Each mark in the array corresponds\n   *           to a row in the data of this DataTable. MarkInfo is currently only partially\n   *           available within results from getSelectedMarksAsync / getMarksAsync.\n   */\n  readonly marksInfo?: Array<MarkInfo>;\n\n  /**\n   * @returns  The column information, including the name, data type, and index..\n   */\n  readonly columns: Array<Column>;\n\n  /**\n   * @returns  The number of rows in the returned data.\n   */\n  readonly totalRowCount: number;\n\n  /**\n   * @returns True if the rows returned have been limited to the maximum number of retrievable rows.\n   *          A value of true indicates that the caller requested more rows than the limit\n   *          and the underlying data source contains more rows than can be returned.\n   *          isTotalRowCountLimited can be true in the case of ...\n   *          `getAllPagesAsync` with more than 4,000,000 rows in the summary or underlying data.\n   *          `getLogicalTableDataAsync` or `getUnderlyingTableDataAsync` with more than 10,000 rows in the data.\n   *          In all these cases, limits can be avoided by processing the data in page sized chunks with `DataTableReader`.\n   *          isTotalRowCountLimited is always false in the results of DataTableReader.getPageAsync().\n   */\n  readonly isTotalRowCountLimited?: boolean;\n\n  /**\n   * @returns  Whether the data is summary data or underlying data.\n   *           Returns true for summary data.\n   */\n  readonly isSummaryData?: boolean;\n}\n\nexport interface DataValue {\n  /* tslint:disable:no-any */\n  /**\n   * @since 1.2.0 Fixes the type to be the raw native value rather than a string.\n   * @returns  Contains the raw native value as a JavaScript type, which is\n   *           one of string, number, boolean, or Date (as a string). Please note that special\n   *           values, regardless of type, are always returned as a String surrounded by\n   *           percent signs, such as '%null%', or '%no-access%'.\n   */\n  readonly value: any;\n\n  /**\n   * @since 1.4.0\n   * @returns The raw native value as a JavaScript type, which is\n   *          one of string, number, boolean, or Date object. Please note that special\n   *          values are returned as null. The actual special value can be found\n   *          in formattedValue, which would be something like 'Null', or 'No-Access'.\n   *          Using nativeValue can greatly simplify your error checking since all values\n   *          will be their native type value or null.\n   */\n  readonly nativeValue: any;\n  /* tslint:enable:no-any */\n\n  /**\n   * @returns  The value formatted according to the locale and the\n   *           formatting applied to the field or parameter.\n   */\n  readonly formattedValue?: string;\n\n  /**\n   * @returns The alias of a value only if `hasAlias` is true.\n   */\n  readonly aliasValue?: string;\n\n  /**\n   * @returns Indicates if the DataValue contains an alias (for DataValues of Parameters with domain restriction type\n   *          `ParameterValueType.List`).\n   */\n  readonly hasAlias?: boolean;\n}\n\n/**\n * Options argument for the Worksheet.GetSummaryDataAsync API\n */\nexport interface GetSummaryDataOptions {\n  /**\n   * Do not use aliases specified in the data source in Tableau. Default is false.\n   */\n  ignoreAliases?: boolean;\n\n  /**\n   * Only return data for the currently selected marks. Default is false.\n   */\n  ignoreSelection?: boolean;\n\n  /**\n   * The columns to return specified by field id, returns all by default.\n   * Since 1.5.0, fieldId is a property of the Column object.\n   *\n   * @since 1.5.0\n   */\n  columnsToIncludeById?: Array<string>;\n\n  /**\n   * The number of rows of data that you want to return. A value of `0` will attempt to return all rows.\n   * `0` is the default if maxRows is not specified.\n   * `getUnderlyingTableDataAsync` - maximum number of rows returned is capped at 10,000 regardless of maxRows.\n   * `getSummaryDataAsync` - maximum number of rows returned is not capped, but performance may suffer with large row counts.\n   *\n   * @since 1.5.0 maxRows is now supported in both `GetSummaryDataOptions` and `GetUnderlyingDataOptions`.\n   * @since 1.10.0 maxRows is ignored when getting a DataTableReader\n   */\n  maxRows?: number;\n\n  /**\n   * Specify which properties to return in DataValues. The default is `IncludeDataValuesOption.AllValues`.\n   * All properties not requested will be `undefined` in the DataValue results.\n   * This is a performance optimization only, and will be ignored in Tableau versions prior to 2021.2.\n   *\n   * @since 1.5.0\n   */\n  includeDataValuesOption?: IncludeDataValuesOption;\n\n  /**\n   * Specifies whether to apply worksheet level formatting to numbers and dates\n   * Note that this is different from the global field formatting degined in the Schema Viewer\n   *\n   * @since 1.13.0 and Tableau 2025.1\n   */\n  applyWorksheetFormatting?: boolean;\n}\n\n/**\n * Options argument for the Worksheet.getUnderlyingTableDataAsync API.\n */\nexport interface GetUnderlyingDataOptions extends GetSummaryDataOptions {\n  /**\n   * Return all the columns for the data source. Default is false.\n   */\n  includeAllColumns?: boolean;\n}\n\n/**\n * A DataTableReader allows iteration over summary or underlying data by pages.\n * The page size is established when the DataTableReader is created.\n * (See getLogicalTableDataReaderAsync, getSummaryDataReaderAsync, or getUnderlyingTableDataReaderAsync.)\n * The normal sequence of operations would be to\n * 1. Create the DataTableReader for the desired DataTable.\n * 2. Use DataTableReader.totalRowCount or DataTableReader.pageCount to discover how many rows or pages are in the desired DataTable.\n * 3. Call DataTableReader.getPageAsync() to get the page(s) desired. Each page is a DataTable for that page.\n *    Alternatively, based on the DataTableReader.totalRowCount, DataTableReader.getAllPagesAsync can be used to fetch the entire DataTable.\n * 4. Call DataTableReader.releaseAsync() to free up resources.\n *\n * Notes for usage of a DataTableReader:\n * 1. Since DataTableReaders consume server resources, an inactive DataTableReader will be automatically\n *    released after 60 minutes of inactivity. (A new DataTableReader can be created at that time, if needed.)\n * 2. Calling getPageAsync() after an explicit or automatic releaseAsync() will throw an exception.\n * 3. Only one active DataTableReader per logical table id is supported.\n * 4. There are still limits on the number of rows supported for underlying and logical data table readers.\n *    The default limit is approximately 1 million rows of data for getUnderlyingTableDataReaderAsync,\n *    and approximately 32 million cells (rows * columns) for getLogicalTableDataReaderAsync.\n *    Administrators may change these limits to better match computing resources with the Tableau Server (Cloud) or Tableau Desktop options:\n *    ExtensionsAndEmbeddingReaderRowLimit for getUnderlyingTableDataReaderAsync or\n *    ExtensionsAndEmbeddingReaderCellLimit for getLogicalTableDataReaderAsync.\n *\n * @since 1.10.0 and Tableau 2022.4\n */\nexport interface DataTableReader {\n  /**\n   * @returns  The number of rows in the full data table.\n   */\n  readonly totalRowCount: number;\n\n  /**\n   * @returns  The number of pages in the full data table. The last page could be a partial page.\n   */\n  readonly pageCount: number;\n\n  /**\n   * Get a page of data. The page is returned as a DataTable.\n   * Calls to getPageAsync() after releaseAsync() will throw an exception.\n   *\n   * @param pageNumber  The page number (zero-indexed) to fetch. The page number should be treated\n   *                    like an array index with range: 0 <= pageNumber < pageCount.\n   * @returns           A DataTable containing the requested page. The number of rows returned\n   *                    can be less than the page size at the end of the data.\n   *\n   * ```\n   * const pageRowCount = 200;\n   * const dataTableReader = await worksheet.getSummaryDataReaderAsync(pageRowCount, options);\n   * for (let currentPage = 0; currentPage < dataTableReader.pageCount; currentPage++) {\n   *   const currentPageDataTable = await dataTableReader.getPageAsync(currentPage);\n   *   // ... process current page ...\n   * }\n   * await dataTableReader.releaseAsync();\n   * ```\n   */\n  getPageAsync(pageNumber: number): Promise<DataTable>;\n\n  /**\n   * Get all the pages of data into a single DataTable.\n   * Calls to getAllPagesAsync() after releaseAsync() will throw an exception.\n   * To protect against possible browser failure, getAllPagesAsync will cap the data at a maximum of 400 pages.\n   * With a default pageRowCount of 10,000 this will give you a maximum of 4,000,000 rows of data.\n   *\n   * If sizes are larger than this, please process your data in page size chunks.\n   * @param maxRows Limits the request to maxRows. If maxRows === 0, requests all rows.\n   * @returns       A DataTable containing all the data available to the DataTableReader with the maximum page count above.\n   *\n   * ```\n   * // To simplify the example, we assume we have less than 4m rows of data\n   * // Since we are fetching all of the data, use the default page size in getSummaryDataReaderAsync\n   * const dataTableReader = await worksheet.getSummaryDataReaderAsync();\n   * const dataTable = await dataTableReader.getAllPagesAsync();\n   * await dataTableReader.releaseAsync();\n   * // ... process the data table ...\n   * ```\n   */\n  getAllPagesAsync(maxRows?: number): Promise<DataTable>;\n\n  /**\n   * Release all resources held by the DataTableReader.\n   * Calling this when done with the DataTableReader is required practice as it frees up resources.\n   * Calls to getPageAsync() after releaseAsync() will throw an exception.\n   */\n  releaseAsync(): Promise<void>;\n}\n"]}